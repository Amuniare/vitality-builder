=== Directory Tree ===
server/
  appsettings.Development.json
  appsettings.json
  Controllers/
    CharactersController.cs
  Domain/
    Attributes/
      CombatAttributesEntity.cs
      UtilityAttributesEntity.cs
    Character/
      Character.cs
      CharacterArchetypes.cs
    Constants/
      GameRuleConstants.cs
    Dtos/
      Archetypes/
        CharacterArchetypesDto.cs
      Attributes/
        CharacterBasicDto.cs
        CharacterResponseDto.cs
      Character/
        CombatAttributesDto.cs
        UtilityAttributesDto.cs
    Enums/
      ArchetypeEnums.cs
    Errors/
      ErrorResponse.cs
      ValidationResults.cs
    ValueObjects/
      CombatStats.cs
  Infrastructure/
    Data/
      Configurations/
        CharacterConfiguration.cs
        CombatAttributesConfiguration.cs
        UtilityAttributesConfiguration.cs
      VitalityBuilderContext.cs
    Security/
      InputSanitizer.cs
    Validation/
      CharacterValidator.cs
      CombatAttributesValidator.cs
      UtilityAttributesValidator.cs
  Interfaces/
    Repositories/
      ICharacterRepository.cs
    Services/
      ICharacterStatCalculator.cs
      IPointPoolCalculator.cs
  migrations/
    20250209215104_InitialCreate.cs
    20250210120258_FixMainPointPoolComputed.cs
    20250210120258_FixMainPointPoolComputed.Designer.cs
    VitalityBuilderContextModelSnapshot.cs
  Program.cs
  Properties/
    launchSettings.json
  Services/
    Calculations/
      CharacterStatCalculator.cs
      PointPoolCalculator.cs
    Character/
      CharacterCreationService.cs
      CharacterUpdateService.cs
    Validation/
      ValidationService.cs
  vitality.db
  VitalityBuilder.Api.csproj

=== File Contents ===

File: server\appsettings.Development.json
Content:
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=VitalityBuilder_Dev;Trusted_Connection=True;MultipleActiveResultSets=true"
  },
  "DetailedErrors": true,
  "Serilog": {
    "MinimumLevel": {
      "Default": "Debug",
      "Override": {
        "Microsoft": "Information",
        "Microsoft.Hosting.Lifetime": "Information",
        "Microsoft.EntityFrameworkCore": "Information"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/vitalitybuilder-dev-.log",
          "rollingInterval": "Day",
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}",
          "shared": true
        }
      },
      {
        "Name": "Debug"
      }
    ]
  },
  "Security": {
    "RequireHttps": false,
    "RequireAuthentication": false,
    "AllowAnonymousCharacters": true,
    "MaxCharactersPerUser": null,
    "RateLimiting": {
      "EnableRateLimiting": false,
      "RequestsPerMinute": 1000,
      "RequestsPerHour": 10000
    }
  },
  "Features": {
    "EnableCharacterSharing": true,
    "EnableCharacterExport": true,
    "EnableDiceRolling": true,
    "EnableCombatSimulation": true,
    "MaxSpecialAttacks": null,
    "MaxFeatures": null,
    "MaxExpertise": null
  },
  "Performance": {
    "EnableCaching": false,
    "CacheTimeInMinutes": 5,
    "MaxConcurrentCalculations": null,
    "EnableQueryOptimization": false
  },
  "Validation": {
    "StrictModeEnabled": false,
    "EnableWarnings": true,
    "MaxWarningsPerCharacter": null,
    "ValidateOnSave": true,
    "DetailedValidationMessages": true
  },
  "Debug": {
    "EnableSensitiveDataLogging": true,
    "EnableDetailedErrors": true,
    "LogAllQueries": true,
    "EnableSqlParameterLogging": true
  }
}
--------------------------------------------------

File: server\appsettings.json
Content:
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=VitalityBuilder;Trusted_Connection=True;MultipleActiveResultSets=true"
  },
  "AllowedHosts": "*",
  "AllowedOrigins": [
    "http://localhost:3000",
    "https://localhost:3000"
  ],
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "Microsoft.Hosting.Lifetime": "Information",
        "Microsoft.EntityFrameworkCore": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/vitalitybuilder-.log",
          "rollingInterval": "Day",
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      }
    ]
  },
  "Security": {
    "RequireHttps": true,
    "RequireAuthentication": false,
    "AllowAnonymousCharacters": true,
    "MaxCharactersPerUser": 10,
    "RateLimiting": {
      "EnableRateLimiting": true,
      "RequestsPerMinute": 60,
      "RequestsPerHour": 1000
    }
  },
  "Features": {
    "EnableCharacterSharing": true,
    "EnableCharacterExport": true,
    "EnableDiceRolling": true,
    "EnableCombatSimulation": false,
    "MaxSpecialAttacks": 10,
    "MaxFeatures": 20,
    "MaxExpertise": 15
  },
  "Performance": {
    "EnableCaching": true,
    "CacheTimeInMinutes": 15,
    "MaxConcurrentCalculations": 10,
    "EnableQueryOptimization": true
  },
  "Validation": {
    "StrictModeEnabled": false,
    "EnableWarnings": true,
    "MaxWarningsPerCharacter": 10,
    "ValidateOnSave": true
  }
}
--------------------------------------------------

File: server\Program.cs
Content:
using FluentValidation;
using Microsoft.EntityFrameworkCore;
using Microsoft.OpenApi.Models;
using Serilog;
using VitalityBuilder.Infrastructure.Data;
using VitalityBuilder.Infrastructure.Security;
using VitalityBuilder.Infrastructure.Validation;
using VitalityBuilder.Interfaces.Repositories;
using VitalityBuilder.Interfaces.Services;
using VitalityBuilder.Services.Calculations;
using VitalityBuilder.Services.Character;
using VitalityBuilder.Services.Validation;

var builder = WebApplication.CreateBuilder(args);

// Configure Serilog
Log.Logger = new LoggerConfiguration()
    .ReadFrom.Configuration(builder.Configuration)
    .CreateLogger();

builder.Host.UseSerilog();

// Add services to the container
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();

// Configure Swagger
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo 
    { 
        Title = "Vitality Builder API", 
        Version = "v1",
        Description = "API for the Vitality System Character Builder"
    });
    
    // Include XML comments
    var xmlFile = $"{System.Reflection.Assembly.GetExecutingAssembly().GetName().Name}.xml";
    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
    c.IncludeXmlComments(xmlPath);
});

// Configure Database
builder.Services.AddDbContext<VitalityBuilderContext>(options =>
    options.UseSqlServer(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        b => b.MigrationsAssembly("VitalityBuilder.Infrastructure")));

// Register Services
builder.Services.AddScoped<ICharacterRepository, CharacterRepository>();
builder.Services.AddScoped<ICharacterCreationService, CharacterCreationService>();
builder.Services.AddScoped<ICharacterUpdateService, CharacterUpdateService>();
builder.Services.AddScoped<ICharacterStatCalculator, CharacterStatCalculator>();
builder.Services.AddScoped<IPointPoolCalculator, PointPoolCalculator>();
builder.Services.AddScoped<IValidationService, ValidationService>();

// Register Validators
builder.Services.AddValidatorsFromAssemblyContaining<CharacterValidator>();

// Configure CORS
builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(policy =>
    {
        policy.WithOrigins(builder.Configuration.GetSection("AllowedOrigins").Get<string[]>() ?? Array.Empty<string>())
              .AllowAnyMethod()
              .AllowAnyHeader();
    });
});

// Add Health Checks
builder.Services.AddHealthChecks()
    .AddDbContextCheck<VitalityBuilderContext>();

var app = builder.Build();

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(c => 
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "Vitality Builder API V1");
        c.RoutePrefix = string.Empty;
    });
}
else
{
    app.UseExceptionHandler("/error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseCors();

// Add security headers
app.Use(async (context, next) =>
{
    context.Response.Headers.Add("X-Content-Type-Options", "nosniff");
    context.Response.Headers.Add("X-Frame-Options", "DENY");
    context.Response.Headers.Add("X-XSS-Protection", "1; mode=block");
    context.Response.Headers.Add("Referrer-Policy", "strict-origin-when-cross-origin");
    context.Response.Headers.Add("Content-Security-Policy", 
        "default-src 'self'; img-src 'self' data:; style-src 'self' 'unsafe-inline';");
    
    await next();
});

// Global error handling
app.UseMiddleware<ErrorHandlingMiddleware>();

app.MapControllers();
app.MapHealthChecks("/health");

// Ensure database is created and migrated
using (var scope = app.Services.CreateScope())
{
    var db = scope.ServiceProvider.GetRequiredService<VitalityBuilderContext>();
    db.Database.Migrate();
}

app.Run();
--------------------------------------------------

File: server\vitality.db
Content:
[Binary or non-UTF-8 file content omitted]
--------------------------------------------------

File: server\VitalityBuilder.Api.csproj
Content:
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <!-- ASP.NET Core -->
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="7.0.13" />
    
    <!-- Entity Framework -->
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="7.0.13" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="7.0.13" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="7.0.13">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>

    <!-- Validation -->
    <PackageReference Include="FluentValidation.AspNetCore" Version="11.3.0" />
    
    <!-- Swagger -->
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    
    <!-- Logging -->
    <PackageReference Include="Serilog.AspNetCore" Version="7.0.0" />
    <PackageReference Include="Serilog.Sinks.Console" Version="4.1.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="5.0.0" />
    
    <!-- Health Checks -->
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" Version="7.0.13" />
    
    <!-- Testing -->
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.7.2" />
    <PackageReference Include="xunit" Version="2.6.1" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.5.3">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Moq" Version="4.20.69" />
  </ItemGroup>

  <ItemGroup>
    <!-- Project References -->
    <ProjectReference Include="..\VitalityBuilder.Domain\VitalityBuilder.Domain.csproj" />
    <ProjectReference Include="..\VitalityBuilder.Infrastructure\VitalityBuilder.Infrastructure.csproj" />
    <ProjectReference Include="..\VitalityBuilder.Services\VitalityBuilder.Services.csproj" />
  </ItemGroup>

  <ItemGroup>
    <!-- Additional Configurations -->
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <None Update="appsettings.Development.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>

</Project>
--------------------------------------------------

File: server\Controllers\CharactersController.cs
Content:
using Microsoft.AspNetCore.Mvc;
using VitalityBuilder.Domain.Dtos.Character;
using VitalityBuilder.Domain.Errors;
using VitalityBuilder.Interfaces.Services;
using VitalityBuilder.Services.Character;

namespace VitalityBuilder.Controllers;

[ApiController]
[Route("api/[controller]")]
public class CharacterController : ControllerBase
{
    private readonly ICharacterService _characterService;
    private readonly IValidationService _validationService;
    private readonly ILogger<CharacterController> _logger;

    public CharacterController(
        ICharacterService characterService,
        IValidationService validationService,
        ILogger<CharacterController> logger)
    {
        _characterService = characterService;
        _validationService = validationService;
        _logger = logger;
    }

    /// <summary>
    /// Creates a new character with the specified attributes and archetypes
    /// </summary>
    /// <param name="request">Character creation details</param>
    /// <returns>The created character or validation errors</returns>
    /// <response code="201">Character created successfully</response>
    /// <response code="400">Invalid character data</response>
    [HttpPost]
    [ProducesResponseType(typeof(CharacterResponseDto), StatusCodes.Status201Created)]
    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
    public async Task<IActionResult> CreateCharacter([FromBody] CreateCharacterDto request)
    {
        try
        {
            _logger.LogInformation("Creating new character with name: {Name}", request.Name);

            // Validate the creation request
            var validationResult = await _validationService.ValidateCharacterCreation(request);
            if (!validationResult.IsValid)
            {
                _logger.LogWarning("Character creation validation failed: {Errors}", 
                    string.Join(", ", validationResult.Errors));
                    
                return BadRequest(new ErrorResponse
                {
                    Message = "Character creation validation failed",
                    Details = validationResult.Errors
                });
            }

            // Process the character creation
            var result = await _characterService.CreateCharacterAsync(request);
            
            _logger.LogInformation("Successfully created character {Id}", result.Id);
            
            return CreatedAtAction(
                nameof(GetCharacter), 
                new { id = result.Id }, 
                result
            );
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating character");
            return StatusCode(500, new ErrorResponse
            {
                Message = "An unexpected error occurred while creating the character"
            });
        }
    }

    /// <summary>
    /// Retrieves a character by their ID
    /// </summary>
    /// <param name="id">Character ID</param>
    /// <returns>The requested character or not found</returns>
    /// <response code="200">Character found</response>
    /// <response code="404">Character not found</response>
    [HttpGet("{id}")]
    [ProducesResponseType(typeof(CharacterResponseDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> GetCharacter(int id)
    {
        try
        {
            _logger.LogInformation("Retrieving character {Id}", id);

            var character = await _characterService.GetCharacterAsync(id);
            if (character == null)
            {
                _logger.LogWarning("Character {Id} not found", id);
                return NotFound();
            }

            return Ok(character);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving character {Id}", id);
            return StatusCode(500, new ErrorResponse
            {
                Message = "An unexpected error occurred while retrieving the character"
            });
        }
    }

    /// <summary>
    /// Updates an existing character's attributes and abilities
    /// </summary>
    /// <param name="id">Character ID</param>
    /// <param name="request">Update details</param>
    /// <returns>The updated character or validation errors</returns>
    /// <response code="200">Character updated successfully</response>
    /// <response code="400">Invalid update data</response>
    /// <response code="404">Character not found</response>
    [HttpPut("{id}")]
    [ProducesResponseType(typeof(CharacterResponseDto), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> UpdateCharacter(
        int id, 
        [FromBody] UpdateCharacterDto request)
    {
        try
        {
            _logger.LogInformation("Updating character {Id}", id);

            // Validate the update request
            var validationResult = await _validationService.ValidateCharacterUpdate(id, request);
            if (!validationResult.IsValid)
            {
                _logger.LogWarning("Character update validation failed: {Errors}",
                    string.Join(", ", validationResult.Errors));
                    
                return BadRequest(new ErrorResponse
                {
                    Message = "Character update validation failed",
                    Details = validationResult.Errors
                });
            }

            // Process the character update
            var result = await _characterService.UpdateCharacterAsync(id, request);
            if (result == null)
            {
                _logger.LogWarning("Character {Id} not found for update", id);
                return NotFound();
            }

            _logger.LogInformation("Successfully updated character {Id}", id);
            return Ok(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating character {Id}", id);
            return StatusCode(500, new ErrorResponse
            {
                Message = "An unexpected error occurred while updating the character"
            });
        }
    }

    /// <summary>
    /// Updates a character's combat attributes
    /// </summary>
    /// <param name="id">Character ID</param>
    /// <param name="request">Combat attribute updates</param>
    /// <returns>The updated character or validation errors</returns>
    [HttpPut("{id}/combat-attributes")]
    [ProducesResponseType(typeof(CharacterResponseDto), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> UpdateCombatAttributes(
        int id, 
        [FromBody] UpdateCombatAttributesDto request)
    {
        try
        {
            _logger.LogInformation("Updating combat attributes for character {Id}", id);

            // Validate the attribute updates
            var validationResult = await _validationService
                .ValidateCombatAttributeUpdate(id, request);
            if (!validationResult.IsValid)
            {
                _logger.LogWarning("Combat attribute update validation failed: {Errors}",
                    string.Join(", ", validationResult.Errors));
                    
                return BadRequest(new ErrorResponse
                {
                    Message = "Combat attribute update validation failed",
                    Details = validationResult.Errors
                });
            }

            // Process the attribute update
            var result = await _characterService.UpdateCombatAttributesAsync(id, request);
            if (result == null)
            {
                _logger.LogWarning("Character {Id} not found for combat attribute update", id);
                return NotFound();
            }

            _logger.LogInformation("Successfully updated combat attributes for character {Id}", id);
            return Ok(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating combat attributes for character {Id}", id);
            return StatusCode(500, new ErrorResponse
            {
                Message = "An unexpected error occurred while updating combat attributes"
            });
        }
    }

    /// <summary>
    /// Updates a character's utility attributes
    /// </summary>
    /// <param name="id">Character ID</param>
    /// <param name="request">Utility attribute updates</param>
    /// <returns>The updated character or validation errors</returns>
    [HttpPut("{id}/utility-attributes")]
    [ProducesResponseType(typeof(CharacterResponseDto), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> UpdateUtilityAttributes(
        int id, 
        [FromBody] UpdateUtilityAttributesDto request)
    {
        try
        {
            _logger.LogInformation("Updating utility attributes for character {Id}", id);

            // Validate the attribute updates
            var validationResult = await _validationService
                .ValidateUtilityAttributeUpdate(id, request);
            if (!validationResult.IsValid)
            {
                _logger.LogWarning("Utility attribute update validation failed: {Errors}",
                    string.Join(", ", validationResult.Errors));
                    
                return BadRequest(new ErrorResponse
                {
                    Message = "Utility attribute update validation failed",
                    Details = validationResult.Errors
                });
            }

            // Process the attribute update
            var result = await _characterService.UpdateUtilityAttributesAsync(id, request);
            if (result == null)
            {
                _logger.LogWarning("Character {Id} not found for utility attribute update", id);
                return NotFound();
            }

            _logger.LogInformation("Successfully updated utility attributes for character {Id}", id);
            return Ok(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating utility attributes for character {Id}", id);
            return StatusCode(500, new ErrorResponse
            {
                Message = "An unexpected error occurred while updating utility attributes"
            });
        }
    }

    /// <summary>
    /// Deletes a character
    /// </summary>
    /// <param name="id">Character ID</param>
    /// <returns>Success or not found</returns>
    /// <response code="204">Character deleted successfully</response>
    /// <response code="404">Character not found</response>
    [HttpDelete("{id}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> DeleteCharacter(int id)
    {
        try
        {
            _logger.LogInformation("Deleting character {Id}", id);

            var result = await _characterService.DeleteCharacterAsync(id);
            if (!result)
            {
                _logger.LogWarning("Character {Id} not found for deletion", id);
                return NotFound();
            }

            _logger.LogInformation("Successfully deleted character {Id}", id);
            return NoContent();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deleting character {Id}", id);
            return StatusCode(500, new ErrorResponse
            {
                Message = "An unexpected error occurred while deleting the character"
            });
        }
    }
}
--------------------------------------------------

File: server\migrations\20250209215104_InitialCreate.cs
Content:
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace VitalityBuilder.Api.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Characters",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Tier = table.Column<int>(type: "int", nullable: false),
                    MainPointPool = table.Column<int>(type: "int", nullable: false),
                    SpecialAttacksPointPool = table.Column<int>(type: "int", nullable: false),
                    UtilityPointPool = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Characters", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "CharacterArchetypes",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    CharacterId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CharacterArchetypes", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CharacterArchetypes_Characters_CharacterId",
                        column: x => x.CharacterId,
                        principalTable: "Characters",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "CombatAttributes",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Focus = table.Column<int>(type: "int", nullable: false),
                    Power = table.Column<int>(type: "int", nullable: false),
                    Mobility = table.Column<int>(type: "int", nullable: false),
                    Endurance = table.Column<int>(type: "int", nullable: false),
                    CharacterId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CombatAttributes", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CombatAttributes_Characters_CharacterId",
                        column: x => x.CharacterId,
                        principalTable: "Characters",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "Expertise",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Category = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Cost = table.Column<int>(type: "int", nullable: false),
                    Description = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    CharacterId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Expertise", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Expertise_Characters_CharacterId",
                        column: x => x.CharacterId,
                        principalTable: "Characters",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "SpecialAttacks",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    AttackType = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    EffectType = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Limits = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Upgrades = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    CharacterId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_SpecialAttacks", x => x.Id);
                    table.ForeignKey(
                        name: "FK_SpecialAttacks_Characters_CharacterId",
                        column: x => x.CharacterId,
                        principalTable: "Characters",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "UniquePowers",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Category = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Cost = table.Column<int>(type: "int", nullable: false),
                    Description = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    CharacterId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_UniquePowers", x => x.Id);
                    table.ForeignKey(
                        name: "FK_UniquePowers_Characters_CharacterId",
                        column: x => x.CharacterId,
                        principalTable: "Characters",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "UtilityAttributes",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Awareness = table.Column<int>(type: "int", nullable: false),
                    Communication = table.Column<int>(type: "int", nullable: false),
                    Intelligence = table.Column<int>(type: "int", nullable: false),
                    CharacterId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_UtilityAttributes", x => x.Id);
                    table.ForeignKey(
                        name: "FK_UtilityAttributes_Characters_CharacterId",
                        column: x => x.CharacterId,
                        principalTable: "Characters",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "AttackTypeArchetype",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Category = table.Column<int>(type: "int", nullable: false),
                    AccuracyPenalty = table.Column<int>(type: "int", nullable: false),
                    EffectPenalty = table.Column<int>(type: "int", nullable: false),
                    BypassesAccuracyChecks = table.Column<bool>(type: "bit", nullable: false),
                    HasFreeAOE = table.Column<bool>(type: "bit", nullable: false),
                    CharacterArchetypesId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AttackTypeArchetype", x => x.Id);
                    table.ForeignKey(
                        name: "FK_AttackTypeArchetype_CharacterArchetypes_CharacterArchetypesId",
                        column: x => x.CharacterArchetypesId,
                        principalTable: "CharacterArchetypes",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "EffectTypeArchetype",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Category = table.Column<int>(type: "int", nullable: false),
                    HasAccessToAdvancedConditions = table.Column<bool>(type: "bit", nullable: false),
                    DamagePenalty = table.Column<int>(type: "int", nullable: false),
                    ConditionPenalty = table.Column<int>(type: "int", nullable: false),
                    RequiresHybridEffects = table.Column<bool>(type: "bit", nullable: false),
                    CharacterArchetypesId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_EffectTypeArchetype", x => x.Id);
                    table.ForeignKey(
                        name: "FK_EffectTypeArchetype_CharacterArchetypes_CharacterArchetypesId",
                        column: x => x.CharacterArchetypesId,
                        principalTable: "CharacterArchetypes",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "MovementArchetype",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Type = table.Column<int>(type: "int", nullable: false),
                    SpeedBonusByTier = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    IgnoresOpportunityAttacks = table.Column<bool>(type: "bit", nullable: false),
                    IgnoresDifficultTerrain = table.Column<bool>(type: "bit", nullable: false),
                    IsImmuneToProne = table.Column<bool>(type: "bit", nullable: false),
                    MovementMultiplier = table.Column<float>(type: "real", nullable: false),
                    CharacterArchetypesId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_MovementArchetype", x => x.Id);
                    table.ForeignKey(
                        name: "FK_MovementArchetype_CharacterArchetypes_CharacterArchetypesId",
                        column: x => x.CharacterArchetypesId,
                        principalTable: "CharacterArchetypes",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "SpecialAttackArchetype",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Category = table.Column<int>(type: "int", nullable: false),
                    BasePoints = table.Column<int>(type: "int", nullable: false),
                    MaxSpecialAttacks = table.Column<int>(type: "int", nullable: false),
                    LimitPointMultiplier = table.Column<float>(type: "real", nullable: false),
                    CanTakeLimits = table.Column<bool>(type: "bit", nullable: false),
                    RequiredLimits = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    CharacterArchetypesId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_SpecialAttackArchetype", x => x.Id);
                    table.ForeignKey(
                        name: "FK_SpecialAttackArchetype_CharacterArchetypes_CharacterArchetypesId",
                        column: x => x.CharacterArchetypesId,
                        principalTable: "CharacterArchetypes",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "UniqueAbilityArchetype",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Category = table.Column<int>(type: "int", nullable: false),
                    ExtraQuickActions = table.Column<int>(type: "int", nullable: false),
                    ExtraPointPool = table.Column<int>(type: "int", nullable: false),
                    StatBonuses = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    CharacterArchetypesId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_UniqueAbilityArchetype", x => x.Id);
                    table.ForeignKey(
                        name: "FK_UniqueAbilityArchetype_CharacterArchetypes_CharacterArchetypesId",
                        column: x => x.CharacterArchetypesId,
                        principalTable: "CharacterArchetypes",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "UtilityArchetype",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Category = table.Column<int>(type: "int", nullable: false),
                    BaseUtilityPool = table.Column<int>(type: "int", nullable: false),
                    CanPurchaseExpertise = table.Column<bool>(type: "bit", nullable: false),
                    TierBonusMultiplier = table.Column<float>(type: "real", nullable: false),
                    Restrictions = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    CharacterArchetypesId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_UtilityArchetype", x => x.Id);
                    table.ForeignKey(
                        name: "FK_UtilityArchetype_CharacterArchetypes_CharacterArchetypesId",
                        column: x => x.CharacterArchetypesId,
                        principalTable: "CharacterArchetypes",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateIndex(
                name: "IX_AttackTypeArchetype_CharacterArchetypesId",
                table: "AttackTypeArchetype",
                column: "CharacterArchetypesId",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_CharacterArchetypes_CharacterId",
                table: "CharacterArchetypes",
                column: "CharacterId");

            migrationBuilder.CreateIndex(
                name: "IX_CombatAttributes_CharacterId",
                table: "CombatAttributes",
                column: "CharacterId",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_EffectTypeArchetype_CharacterArchetypesId",
                table: "EffectTypeArchetype",
                column: "CharacterArchetypesId",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_Expertise_CharacterId",
                table: "Expertise",
                column: "CharacterId");

            migrationBuilder.CreateIndex(
                name: "IX_MovementArchetype_CharacterArchetypesId",
                table: "MovementArchetype",
                column: "CharacterArchetypesId",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_SpecialAttackArchetype_CharacterArchetypesId",
                table: "SpecialAttackArchetype",
                column: "CharacterArchetypesId",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_SpecialAttacks_CharacterId",
                table: "SpecialAttacks",
                column: "CharacterId");

            migrationBuilder.CreateIndex(
                name: "IX_UniqueAbilityArchetype_CharacterArchetypesId",
                table: "UniqueAbilityArchetype",
                column: "CharacterArchetypesId",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_UniquePowers_CharacterId",
                table: "UniquePowers",
                column: "CharacterId");

            migrationBuilder.CreateIndex(
                name: "IX_UtilityArchetype_CharacterArchetypesId",
                table: "UtilityArchetype",
                column: "CharacterArchetypesId",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_UtilityAttributes_CharacterId",
                table: "UtilityAttributes",
                column: "CharacterId",
                unique: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "AttackTypeArchetype");

            migrationBuilder.DropTable(
                name: "CombatAttributes");

            migrationBuilder.DropTable(
                name: "EffectTypeArchetype");

            migrationBuilder.DropTable(
                name: "Expertise");

            migrationBuilder.DropTable(
                name: "MovementArchetype");

            migrationBuilder.DropTable(
                name: "SpecialAttackArchetype");

            migrationBuilder.DropTable(
                name: "SpecialAttacks");

            migrationBuilder.DropTable(
                name: "UniqueAbilityArchetype");

            migrationBuilder.DropTable(
                name: "UniquePowers");

            migrationBuilder.DropTable(
                name: "UtilityArchetype");

            migrationBuilder.DropTable(
                name: "UtilityAttributes");

            migrationBuilder.DropTable(
                name: "CharacterArchetypes");

            migrationBuilder.DropTable(
                name: "Characters");
        }
    }
}

--------------------------------------------------

File: server\migrations\20250210120258_FixMainPointPoolComputed.cs
Content:
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace VitalityBuilder.Api.Migrations
{
    /// <inheritdoc />
    public partial class FixMainPointPoolComputed : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropIndex(
                name: "IX_CharacterArchetypes_CharacterId",
                table: "CharacterArchetypes");

            migrationBuilder.AddColumn<int>(
                name: "Cost",
                table: "SpecialAttacks",
                type: "int",
                nullable: false,
                defaultValue: 0);

            migrationBuilder.AddColumn<int>(
                name: "Total",
                table: "CombatAttributes",
                type: "int",
                nullable: false,
                defaultValue: 0);

            migrationBuilder.AlterColumn<int>(
                name: "MainPointPool",
                table: "Characters",
                type: "int",
                nullable: false,
                computedColumnSql: "CASE WHEN [Tier] >= 2 THEN ([Tier] - 2) * 15 ELSE 0 END",
                oldClrType: typeof(int),
                oldType: "int");

            migrationBuilder.CreateIndex(
                name: "IX_CharacterArchetypes_CharacterId",
                table: "CharacterArchetypes",
                column: "CharacterId",
                unique: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropIndex(
                name: "IX_CharacterArchetypes_CharacterId",
                table: "CharacterArchetypes");

            migrationBuilder.DropColumn(
                name: "Cost",
                table: "SpecialAttacks");

            migrationBuilder.DropColumn(
                name: "Total",
                table: "CombatAttributes");

            migrationBuilder.AlterColumn<int>(
                name: "MainPointPool",
                table: "Characters",
                type: "int",
                nullable: false,
                oldClrType: typeof(int),
                oldType: "int",
                oldComputedColumnSql: "CASE WHEN [Tier] >= 2 THEN ([Tier] - 2) * 15 ELSE 0 END");

            migrationBuilder.CreateIndex(
                name: "IX_CharacterArchetypes_CharacterId",
                table: "CharacterArchetypes",
                column: "CharacterId");
        }
    }
}

--------------------------------------------------

File: server\migrations\20250210120258_FixMainPointPoolComputed.Designer.cs
Content:
﻿// <auto-generated />
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using VitalityBuilder.Api.Infrastructure;

#nullable disable

namespace VitalityBuilder.Api.Migrations
{
    [DbContext(typeof(VitalityBuilderContext))]
    [Migration("20250210120258_FixMainPointPoolComputed")]
    partial class FixMainPointPoolComputed
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.1")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.AttackTypeArchetype", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("AccuracyPenalty")
                        .HasColumnType("int");

                    b.Property<bool>("BypassesAccuracyChecks")
                        .HasColumnType("bit");

                    b.Property<int>("Category")
                        .HasColumnType("int");

                    b.Property<int>("CharacterArchetypesId")
                        .HasColumnType("int");

                    b.Property<int>("EffectPenalty")
                        .HasColumnType("int");

                    b.Property<bool>("HasFreeAOE")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("CharacterArchetypesId")
                        .IsUnique();

                    b.ToTable("AttackTypeArchetype");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("CharacterId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("CharacterId")
                        .IsUnique();

                    b.ToTable("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.EffectTypeArchetype", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("Category")
                        .HasColumnType("int");

                    b.Property<int>("CharacterArchetypesId")
                        .HasColumnType("int");

                    b.Property<int>("ConditionPenalty")
                        .HasColumnType("int");

                    b.Property<int>("DamagePenalty")
                        .HasColumnType("int");

                    b.Property<bool>("HasAccessToAdvancedConditions")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("RequiresHybridEffects")
                        .HasColumnType("bit");

                    b.HasKey("Id");

                    b.HasIndex("CharacterArchetypesId")
                        .IsUnique();

                    b.ToTable("EffectTypeArchetype");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.MovementArchetype", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("CharacterArchetypesId")
                        .HasColumnType("int");

                    b.Property<bool>("IgnoresDifficultTerrain")
                        .HasColumnType("bit");

                    b.Property<bool>("IgnoresOpportunityAttacks")
                        .HasColumnType("bit");

                    b.Property<bool>("IsImmuneToProne")
                        .HasColumnType("bit");

                    b.Property<float>("MovementMultiplier")
                        .HasColumnType("real");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("SpeedBonusByTier")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Type")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("CharacterArchetypesId")
                        .IsUnique();

                    b.ToTable("MovementArchetype");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.SpecialAttackArchetype", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("BasePoints")
                        .HasColumnType("int");

                    b.Property<bool>("CanTakeLimits")
                        .HasColumnType("bit");

                    b.Property<int>("Category")
                        .HasColumnType("int");

                    b.Property<int>("CharacterArchetypesId")
                        .HasColumnType("int");

                    b.Property<float>("LimitPointMultiplier")
                        .HasColumnType("real");

                    b.Property<int>("MaxSpecialAttacks")
                        .HasColumnType("int");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.PrimitiveCollection<string>("RequiredLimits")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("CharacterArchetypesId")
                        .IsUnique();

                    b.ToTable("SpecialAttackArchetype");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.UniqueAbilityArchetype", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("Category")
                        .HasColumnType("int");

                    b.Property<int>("CharacterArchetypesId")
                        .HasColumnType("int");

                    b.Property<int>("ExtraPointPool")
                        .HasColumnType("int");

                    b.Property<int>("ExtraQuickActions")
                        .HasColumnType("int");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("StatBonuses")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("CharacterArchetypesId")
                        .IsUnique();

                    b.ToTable("UniqueAbilityArchetype");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.UtilityArchetype", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("BaseUtilityPool")
                        .HasColumnType("int");

                    b.Property<bool>("CanPurchaseExpertise")
                        .HasColumnType("bit");

                    b.Property<int>("Category")
                        .HasColumnType("int");

                    b.Property<int>("CharacterArchetypesId")
                        .HasColumnType("int");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Restrictions")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<float>("TierBonusMultiplier")
                        .HasColumnType("real");

                    b.HasKey("Id");

                    b.HasIndex("CharacterArchetypesId")
                        .IsUnique();

                    b.ToTable("UtilityArchetype");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.Character", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("MainPointPool")
                        .ValueGeneratedOnAddOrUpdate()
                        .HasColumnType("int")
                        .HasComputedColumnSql("CASE WHEN [Tier] >= 2 THEN ([Tier] - 2) * 15 ELSE 0 END");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("SpecialAttacksPointPool")
                        .HasColumnType("int");

                    b.Property<int>("Tier")
                        .HasColumnType("int");

                    b.Property<int>("UtilityPointPool")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("Characters");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.CombatAttributes", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("CharacterId")
                        .HasColumnType("int");

                    b.Property<int>("Endurance")
                        .HasColumnType("int");

                    b.Property<int>("Focus")
                        .HasColumnType("int");

                    b.Property<int>("Mobility")
                        .HasColumnType("int");

                    b.Property<int>("Power")
                        .HasColumnType("int");

                    b.Property<int>("Total")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("CharacterId")
                        .IsUnique();

                    b.ToTable("CombatAttributes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.Expertise", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Category")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("CharacterId")
                        .HasColumnType("int");

                    b.Property<int>("Cost")
                        .HasColumnType("int");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("CharacterId");

                    b.ToTable("Expertise");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.SpecialAttack", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("AttackType")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("CharacterId")
                        .HasColumnType("int");

                    b.Property<int>("Cost")
                        .HasColumnType("int");

                    b.Property<string>("EffectType")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Limits")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Upgrades")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("CharacterId");

                    b.ToTable("SpecialAttacks");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.UniquePower", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Category")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("CharacterId")
                        .HasColumnType("int");

                    b.Property<int>("Cost")
                        .HasColumnType("int");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("CharacterId");

                    b.ToTable("UniquePowers");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.UtilityAttributes", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("Awareness")
                        .HasColumnType("int");

                    b.Property<int>("CharacterId")
                        .HasColumnType("int");

                    b.Property<int>("Communication")
                        .HasColumnType("int");

                    b.Property<int>("Intelligence")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("CharacterId")
                        .IsUnique();

                    b.ToTable("UtilityAttributes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.AttackTypeArchetype", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterArchetypes")
                        .WithOne("AttackTypeArchetype")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.AttackTypeArchetype", "CharacterArchetypesId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Entities.Character", "Character")
                        .WithOne("CharacterArchetypes")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Character");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.EffectTypeArchetype", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterArchetypes")
                        .WithOne("EffectTypeArchetype")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.EffectTypeArchetype", "CharacterArchetypesId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.MovementArchetype", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterArchetypes")
                        .WithOne("MovementArchetype")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.MovementArchetype", "CharacterArchetypesId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.SpecialAttackArchetype", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterArchetypes")
                        .WithOne("SpecialAttackArchetype")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.SpecialAttackArchetype", "CharacterArchetypesId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.UniqueAbilityArchetype", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterArchetypes")
                        .WithOne("UniqueAbilityArchetype")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.UniqueAbilityArchetype", "CharacterArchetypesId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.UtilityArchetype", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterArchetypes")
                        .WithOne("UtilityArchetype")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.UtilityArchetype", "CharacterArchetypesId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.CombatAttributes", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Entities.Character", "Character")
                        .WithOne("CombatAttributes")
                        .HasForeignKey("VitalityBuilder.Api.Models.Entities.CombatAttributes", "CharacterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Character");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.Expertise", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Entities.Character", "Character")
                        .WithMany("Expertise")
                        .HasForeignKey("CharacterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Character");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.SpecialAttack", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Entities.Character", "Character")
                        .WithMany("SpecialAttacks")
                        .HasForeignKey("CharacterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Character");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.UniquePower", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Entities.Character", "Character")
                        .WithMany("UniquePowers")
                        .HasForeignKey("CharacterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Character");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.UtilityAttributes", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Entities.Character", "Character")
                        .WithOne("UtilityAttributes")
                        .HasForeignKey("VitalityBuilder.Api.Models.Entities.UtilityAttributes", "CharacterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Character");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", b =>
                {
                    b.Navigation("AttackTypeArchetype")
                        .IsRequired();

                    b.Navigation("EffectTypeArchetype")
                        .IsRequired();

                    b.Navigation("MovementArchetype")
                        .IsRequired();

                    b.Navigation("SpecialAttackArchetype")
                        .IsRequired();

                    b.Navigation("UniqueAbilityArchetype")
                        .IsRequired();

                    b.Navigation("UtilityArchetype")
                        .IsRequired();
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.Character", b =>
                {
                    b.Navigation("CharacterArchetypes");

                    b.Navigation("CombatAttributes");

                    b.Navigation("Expertise");

                    b.Navigation("SpecialAttacks");

                    b.Navigation("UniquePowers");

                    b.Navigation("UtilityAttributes");
                });
#pragma warning restore 612, 618
        }
    }
}

--------------------------------------------------

File: server\migrations\VitalityBuilderContextModelSnapshot.cs
Content:
﻿// <auto-generated />
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using VitalityBuilder.Api.Infrastructure;

#nullable disable

namespace VitalityBuilder.Api.Migrations
{
    [DbContext(typeof(VitalityBuilderContext))]
    partial class VitalityBuilderContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.1")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.AttackTypeArchetype", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("AccuracyPenalty")
                        .HasColumnType("int");

                    b.Property<bool>("BypassesAccuracyChecks")
                        .HasColumnType("bit");

                    b.Property<int>("Category")
                        .HasColumnType("int");

                    b.Property<int>("CharacterArchetypesId")
                        .HasColumnType("int");

                    b.Property<int>("EffectPenalty")
                        .HasColumnType("int");

                    b.Property<bool>("HasFreeAOE")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("CharacterArchetypesId")
                        .IsUnique();

                    b.ToTable("AttackTypeArchetype");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("CharacterId")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("CharacterId")
                        .IsUnique();

                    b.ToTable("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.EffectTypeArchetype", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("Category")
                        .HasColumnType("int");

                    b.Property<int>("CharacterArchetypesId")
                        .HasColumnType("int");

                    b.Property<int>("ConditionPenalty")
                        .HasColumnType("int");

                    b.Property<int>("DamagePenalty")
                        .HasColumnType("int");

                    b.Property<bool>("HasAccessToAdvancedConditions")
                        .HasColumnType("bit");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("RequiresHybridEffects")
                        .HasColumnType("bit");

                    b.HasKey("Id");

                    b.HasIndex("CharacterArchetypesId")
                        .IsUnique();

                    b.ToTable("EffectTypeArchetype");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.MovementArchetype", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("CharacterArchetypesId")
                        .HasColumnType("int");

                    b.Property<bool>("IgnoresDifficultTerrain")
                        .HasColumnType("bit");

                    b.Property<bool>("IgnoresOpportunityAttacks")
                        .HasColumnType("bit");

                    b.Property<bool>("IsImmuneToProne")
                        .HasColumnType("bit");

                    b.Property<float>("MovementMultiplier")
                        .HasColumnType("real");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("SpeedBonusByTier")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("Type")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("CharacterArchetypesId")
                        .IsUnique();

                    b.ToTable("MovementArchetype");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.SpecialAttackArchetype", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("BasePoints")
                        .HasColumnType("int");

                    b.Property<bool>("CanTakeLimits")
                        .HasColumnType("bit");

                    b.Property<int>("Category")
                        .HasColumnType("int");

                    b.Property<int>("CharacterArchetypesId")
                        .HasColumnType("int");

                    b.Property<float>("LimitPointMultiplier")
                        .HasColumnType("real");

                    b.Property<int>("MaxSpecialAttacks")
                        .HasColumnType("int");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.PrimitiveCollection<string>("RequiredLimits")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("CharacterArchetypesId")
                        .IsUnique();

                    b.ToTable("SpecialAttackArchetype");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.UniqueAbilityArchetype", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("Category")
                        .HasColumnType("int");

                    b.Property<int>("CharacterArchetypesId")
                        .HasColumnType("int");

                    b.Property<int>("ExtraPointPool")
                        .HasColumnType("int");

                    b.Property<int>("ExtraQuickActions")
                        .HasColumnType("int");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("StatBonuses")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("CharacterArchetypesId")
                        .IsUnique();

                    b.ToTable("UniqueAbilityArchetype");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.UtilityArchetype", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("BaseUtilityPool")
                        .HasColumnType("int");

                    b.Property<bool>("CanPurchaseExpertise")
                        .HasColumnType("bit");

                    b.Property<int>("Category")
                        .HasColumnType("int");

                    b.Property<int>("CharacterArchetypesId")
                        .HasColumnType("int");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Restrictions")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<float>("TierBonusMultiplier")
                        .HasColumnType("real");

                    b.HasKey("Id");

                    b.HasIndex("CharacterArchetypesId")
                        .IsUnique();

                    b.ToTable("UtilityArchetype");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.Character", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("MainPointPool")
                        .ValueGeneratedOnAddOrUpdate()
                        .HasColumnType("int")
                        .HasComputedColumnSql("CASE WHEN [Tier] >= 2 THEN ([Tier] - 2) * 15 ELSE 0 END");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("SpecialAttacksPointPool")
                        .HasColumnType("int");

                    b.Property<int>("Tier")
                        .HasColumnType("int");

                    b.Property<int>("UtilityPointPool")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.ToTable("Characters");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.CombatAttributes", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("CharacterId")
                        .HasColumnType("int");

                    b.Property<int>("Endurance")
                        .HasColumnType("int");

                    b.Property<int>("Focus")
                        .HasColumnType("int");

                    b.Property<int>("Mobility")
                        .HasColumnType("int");

                    b.Property<int>("Power")
                        .HasColumnType("int");

                    b.Property<int>("Total")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("CharacterId")
                        .IsUnique();

                    b.ToTable("CombatAttributes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.Expertise", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Category")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("CharacterId")
                        .HasColumnType("int");

                    b.Property<int>("Cost")
                        .HasColumnType("int");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("CharacterId");

                    b.ToTable("Expertise");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.SpecialAttack", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("AttackType")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("CharacterId")
                        .HasColumnType("int");

                    b.Property<int>("Cost")
                        .HasColumnType("int");

                    b.Property<string>("EffectType")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Limits")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Upgrades")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("CharacterId");

                    b.ToTable("SpecialAttacks");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.UniquePower", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Category")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<int>("CharacterId")
                        .HasColumnType("int");

                    b.Property<int>("Cost")
                        .HasColumnType("int");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.HasIndex("CharacterId");

                    b.ToTable("UniquePowers");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.UtilityAttributes", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("Awareness")
                        .HasColumnType("int");

                    b.Property<int>("CharacterId")
                        .HasColumnType("int");

                    b.Property<int>("Communication")
                        .HasColumnType("int");

                    b.Property<int>("Intelligence")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("CharacterId")
                        .IsUnique();

                    b.ToTable("UtilityAttributes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.AttackTypeArchetype", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterArchetypes")
                        .WithOne("AttackTypeArchetype")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.AttackTypeArchetype", "CharacterArchetypesId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Entities.Character", "Character")
                        .WithOne("CharacterArchetypes")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Character");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.EffectTypeArchetype", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterArchetypes")
                        .WithOne("EffectTypeArchetype")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.EffectTypeArchetype", "CharacterArchetypesId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.MovementArchetype", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterArchetypes")
                        .WithOne("MovementArchetype")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.MovementArchetype", "CharacterArchetypesId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.SpecialAttackArchetype", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterArchetypes")
                        .WithOne("SpecialAttackArchetype")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.SpecialAttackArchetype", "CharacterArchetypesId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.UniqueAbilityArchetype", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterArchetypes")
                        .WithOne("UniqueAbilityArchetype")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.UniqueAbilityArchetype", "CharacterArchetypesId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.UtilityArchetype", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", "CharacterArchetypes")
                        .WithOne("UtilityArchetype")
                        .HasForeignKey("VitalityBuilder.Api.Models.Archetypes.UtilityArchetype", "CharacterArchetypesId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("CharacterArchetypes");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.CombatAttributes", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Entities.Character", "Character")
                        .WithOne("CombatAttributes")
                        .HasForeignKey("VitalityBuilder.Api.Models.Entities.CombatAttributes", "CharacterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Character");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.Expertise", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Entities.Character", "Character")
                        .WithMany("Expertise")
                        .HasForeignKey("CharacterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Character");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.SpecialAttack", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Entities.Character", "Character")
                        .WithMany("SpecialAttacks")
                        .HasForeignKey("CharacterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Character");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.UniquePower", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Entities.Character", "Character")
                        .WithMany("UniquePowers")
                        .HasForeignKey("CharacterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Character");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.UtilityAttributes", b =>
                {
                    b.HasOne("VitalityBuilder.Api.Models.Entities.Character", "Character")
                        .WithOne("UtilityAttributes")
                        .HasForeignKey("VitalityBuilder.Api.Models.Entities.UtilityAttributes", "CharacterId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Character");
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Archetypes.CharacterArchetypes", b =>
                {
                    b.Navigation("AttackTypeArchetype")
                        .IsRequired();

                    b.Navigation("EffectTypeArchetype")
                        .IsRequired();

                    b.Navigation("MovementArchetype")
                        .IsRequired();

                    b.Navigation("SpecialAttackArchetype")
                        .IsRequired();

                    b.Navigation("UniqueAbilityArchetype")
                        .IsRequired();

                    b.Navigation("UtilityArchetype")
                        .IsRequired();
                });

            modelBuilder.Entity("VitalityBuilder.Api.Models.Entities.Character", b =>
                {
                    b.Navigation("CharacterArchetypes");

                    b.Navigation("CombatAttributes");

                    b.Navigation("Expertise");

                    b.Navigation("SpecialAttacks");

                    b.Navigation("UniquePowers");

                    b.Navigation("UtilityAttributes");
                });
#pragma warning restore 612, 618
        }
    }
}

--------------------------------------------------

File: server\Properties\launchSettings.json
Content:
﻿{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:5000",
      "sslPort": 5001
    }
  },
  "profiles": {
    "VitalityBuilder.Development": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "",
      "applicationUrl": "https://localhost:5001;http://localhost:5000",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "VitalityBuilder.Production": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "launchUrl": "",
      "applicationUrl": "https://localhost:5001;http://localhost:5000",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Production"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "launchUrl": "",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "Docker": {
      "commandName": "Docker",
      "launchBrowser": true,
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "publishAllPorts": true,
      "useSSL": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "ASPNETCORE_URLS": "https://+:443;http://+:80"
      }
    },
    "Watch": {
      "commandName": "Executable",
      "executablePath": "dotnet",
      "workingDirectory": "$(ProjectDir)",
      "hotReloadEnabled": true,
      "hotReloadProfile": "aspnetcore",
      "commandLineArgs": "watch run",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
--------------------------------------------------

File: server\Services\Calculations\CharacterStatCalculator.cs
Content:
using VitalityBuilder.Domain.Character;
using VitalityBuilder.Domain.Constants;
using VitalityBuilder.Domain.ValueObjects;
using VitalityBuilder.Interfaces.Services;

namespace VitalityBuilder.Services.Calculations;

public class CharacterStatCalculator : ICharacterStatCalculator
{
    public CombatStats CalculateAllStats(Character character)
    {
        var stats = new CombatStats
        {
            // Base Defense Values
            Avoidance = CalculateAvoidance(character),
            Durability = CalculateDurability(character),
            MovementSpeed = CalculateMovementSpeed(character),

            // Core Combat Values
            Initiative = CalculateInitiative(character),
            BaseAccuracyBonus = CalculateBaseAccuracy(character),
            BaseDamageBonus = CalculateBaseDamage(character),
            BaseConditionBonus = CalculateBaseCondition(character),

            // Resistances
            ResolveResistance = CalculateResolveResistance(character),
            StabilityResistance = CalculateStabilityResistance(character),
            VitalityResistance = CalculateVitalityResistance(character)
        };

        // Apply archetype modifiers
        ApplyArchetypeModifiers(stats, character);

        return stats;
    }

    private int CalculateAvoidance(Character character)
    {
        return GameRuleConstants.BaseResistanceValue +
               character.Tier +
               character.CombatAttributes.Mobility;
    }

    private int CalculateDurability(Character character)
    {
        return character.Tier +
               (int)Math.Ceiling(character.CombatAttributes.Endurance * 
                                GameRuleConstants.EnduranceMultiplier);
    }

    private int CalculateMovementSpeed(Character character)
    {
        // Calculate base movement
        var baseSpeed = Math.Max(
            GameRuleConstants.BaseMovementSpeed + character.CombatAttributes.Mobility,
            character.CombatAttributes.Mobility + character.Tier
        );

        // Apply archetype modifiers
        return character.Archetypes.ApplyMovementModifiers(
            baseSpeed, 
            character.Tier, 
            character.CombatAttributes.Endurance
        );
    }

    private int CalculateInitiative(Character character)
    {
        return character.CombatAttributes.Focus +
               character.UtilityAttributes.Awareness;
    }

    private int CalculateBaseAccuracy(Character character)
    {
        var baseAccuracy = character.Tier + character.CombatAttributes.Focus;
        return character.Archetypes.ApplyAttackModifiers(baseAccuracy, character.Tier);
    }

    private int CalculateBaseDamage(Character character)
    {
        var baseDamage = character.Tier + 
                        (int)Math.Ceiling(character.CombatAttributes.Power * 
                                        GameRuleConstants.EnduranceMultiplier);
        
        var (modifiedDamage, _) = character.Archetypes.ApplyEffectModifiers(
            baseDamage, 
            0, 
            character.Tier
        );
        
        return modifiedDamage;
    }

    private int CalculateBaseCondition(Character character)
    {
        var baseCondition = character.Tier * 2;
        var (_, modifiedCondition) = character.Archetypes.ApplyEffectModifiers(
            0, 
            baseCondition, 
            character.Tier
        );
        
        return modifiedCondition;
    }

    private int CalculateResolveResistance(Character character)
    {
        return GameRuleConstants.BaseResistanceValue +
               character.Tier +
               character.CombatAttributes.Focus;
    }

    private int CalculateStabilityResistance(Character character)
    {
        return GameRuleConstants.BaseResistanceValue +
               character.Tier +
               character.CombatAttributes.Power;
    }

    private int CalculateVitalityResistance(Character character)
    {
        return GameRuleConstants.BaseResistanceValue +
               character.Tier +
               character.CombatAttributes.Endurance;
    }

    private void ApplyArchetypeModifiers(CombatStats stats, Character character)
    {
        // Apply attack archetype effects
        if (character.Archetypes.AttackType == AttackArchetype.AOESpecialist)
        {
            stats.BaseAccuracyBonus -= character.Tier;
        }
        else if (character.Archetypes.AttackType == AttackArchetype.DirectSpecialist)
        {
            stats.BaseConditionBonus -= character.Tier;
        }

        // Apply effect archetype modifiers
        if (character.Archetypes.EffectType == EffectArchetype.HybridSpecialist)
        {
            stats.BaseDamageBonus -= character.Tier;
            stats.BaseConditionBonus -= character.Tier;
        }
        else if (character.Archetypes.EffectType == EffectArchetype.CrowdControl)
        {
            stats.BaseDamageBonus -= character.Tier;
        }

        // Apply movement archetype effects
        switch (character.Archetypes.MovementType)
        {
            case MovementArchetype.Swift:
                stats.MovementSpeed += (int)Math.Ceiling(character.Tier / 2.0);
                break;
            case MovementArchetype.Vanguard:
                stats.MovementSpeed += character.CombatAttributes.Endurance;
                break;
            case MovementArchetype.Portal:
                stats.MovementSpeed -= 2;
                break;
        }

        // Apply unique ability effects
        if (character.Archetypes.UniqueAbility == UniqueAbilityArchetype.CutAbove)
        {
            var bonus = character.Tier switch
            {
                <= 4 => 1,
                <= 7 => 2,
                _ => 3
            };
            
            stats.BaseAccuracyBonus += bonus;
            stats.BaseDamageBonus += bonus;
            stats.BaseConditionBonus += bonus;
            stats.Avoidance += bonus;
            stats.Durability += bonus;
            stats.MovementSpeed += bonus;
            stats.ResolveResistance += bonus;
            stats.StabilityResistance += bonus;
            stats.VitalityResistance += bonus;
        }
    }
}
--------------------------------------------------

File: server\Services\Calculations\PointPoolCalculator.cs
Content:
using VitalityBuilder.Domain.Character;
using VitalityBuilder.Domain.Constants;
using VitalityBuilder.Interfaces.Services;

namespace VitalityBuilder.Services.Calculations;

public class PointPoolCalculator : IPointPoolCalculator
{
    public PointPools CalculateAllPools(Character character)
    {
        return new PointPools
        {
            MainPool = CalculateMainPool(character),
            UtilityPoints = CalculateUtilityPoints(character),
            CombatAttributePoints = CalculateCombatAttributePoints(character),
            UtilityAttributePoints = CalculateUtilityAttributePoints(character),
            SpecialAttackPoints = CalculateSpecialAttackPoints(character)
        };
    }

    private int CalculateMainPool(Character character)
    {
        var basePool = GameRuleConstants.CalculateMainPool(character.Tier);

        // Apply archetype modifiers
        if (character.Archetypes.UniqueAbility == UniqueAbilityArchetype.Extraordinary)
        {
            basePool += GameRuleConstants.CalculateMainPool(character.Tier);
        }

        return basePool;
    }

    private int CalculateUtilityPoints(Character character)
    {
        var basePoints = GameRuleConstants.CalculateUtilityPoints(character.Tier);

        // Apply archetype modifier
        var multiplier = character.Archetypes.GetUtilityPointMultiplier();
        return (int)(basePoints * multiplier);
    }

    private int CalculateCombatAttributePoints(Character character)
    {
        return GameRuleConstants.CombatAttributePointsMultiplier * character.Tier;
    }

    private int CalculateUtilityAttributePoints(Character character)
    {
        return character.Tier;
    }

    private int CalculateSpecialAttackPoints(Character character)
    {
        // Calculate base points from limits
        var limitPoints = CalculateLimitPoints(character);

        // Apply archetype modifications
        return character.Archetypes.CalculateSpecialAttackPoints(
            character.Tier, 
            limitPoints
        );
    }

    private int CalculateLimitPoints(Character character)
    {
        var totalLimitValue = 0;
        foreach (var attack in character.SpecialAttacks)
        {
            var limitValues = attack.Limits.Sum(l => GetLimitValue(l));
            totalLimitValue += CalculateLimitPointValue(limitValues, character.Tier);
        }
        return totalLimitValue;
    }

    private int CalculateLimitPointValue(int limitValue, int tier)
    {
        var fullValueLimit = GameRuleConstants.SpecialAttackLimits.CalculateFullValueLimit(tier);
        var halfValueLimit = GameRuleConstants.SpecialAttackLimits.CalculateHalfValueLimit(tier);

        var fullValuePoints = Math.Min(limitValue, fullValueLimit);
        var halfValuePoints = Math.Min(
            Math.Max(0, limitValue - fullValueLimit),
            halfValueLimit
        );
        var quarterValuePoints = Math.Max(0, limitValue - fullValueLimit - halfValueLimit);

        return fullValuePoints +
               (int)(halfValuePoints * GameRuleConstants.SpecialAttackLimits.HalfValueMultiplier) +
               (int)(quarterValuePoints * GameRuleConstants.SpecialAttackLimits.QuarterValueMultiplier);
    }

    private int GetLimitValue(string limit)
    {
        // Implementation would match limit names to their point values
        // This would likely use a dictionary or switch statement
        return limit.ToLower() switch
        {
            "reload" => 20,
            "stockpile" => 40,
            "cooldown2" => 20,
            "cooldown3" => 30,
            "reserves3" => 10,
            "reserves2" => 20,
            "reserves1" => 40,
            "finite5" => 10,
            "finite3" => 20,
            "finite2" => 30,
            "finite1" => 50,
            "charger" => 10,
            "slowed" => 10,
            "focused" => 30,
            "unhealthy" => 30,
            "healthy" => 20,
            "timid" => 50,
            "avenger" => 50,
            "purist" => 10,
            _ => 0
        };
    }

    public ValidationResult ValidatePointAllocation(Character character)
    {
        var pools = CalculateAllPools(character);
        var result = new ValidationResult();

        // Validate main pool
        if (character.SpentMainPoints > pools.MainPool)
        {
            result.AddError($"Main pool overspent by {character.SpentMainPoints - pools.MainPool} points");
        }

        // Validate utility points
        if (character.SpentUtilityPoints > pools.UtilityPoints)
        {
            result.AddError($"Utility points overspent by {character.SpentUtilityPoints - pools.UtilityPoints} points");
        }

        // Validate combat attributes
        var spentCombatPoints = character.CombatAttributes.TotalPoints;
        if (spentCombatPoints > pools.CombatAttributePoints)
        {
            result.AddError($"Combat attribute points overspent by {spentCombatPoints - pools.CombatAttributePoints} points");
        }

        // Validate utility attributes
        var spentUtilityPoints = character.UtilityAttributes.TotalPoints;
        if (spentUtilityPoints > pools.UtilityAttributePoints)
        {
            result.AddError($"Utility attribute points overspent by {spentUtilityPoints - pools.UtilityAttributePoints} points");
        }

        // Add warnings for unspent points
        if (pools.MainPool - character.SpentMainPoints > 0)
        {
            result.AddWarning($"Unspent main pool points: {pools.MainPool - character.SpentMainPoints}");
        }

        if (pools.UtilityPoints - character.SpentUtilityPoints > 0)
        {
            result.AddWarning($"Unspent utility points: {pools.UtilityPoints - character.SpentUtilityPoints}");
        }

        return result;
    }
}

public class PointPools
{
    public int MainPool { get; set; }
    public int UtilityPoints { get; set; }
    public int CombatAttributePoints { get; set; }
    public int UtilityAttributePoints { get; set; }
    public int SpecialAttackPoints { get; set; }
}

public class ValidationResult
{
    public bool IsValid => !Errors.Any();
    public List<string> Errors { get; } = new();
    public List<string> Warnings { get; } = new();

    public void AddError(string error) => Errors.Add(error);
    public void AddWarning(string warning) => Warnings.Add(warning);
}
--------------------------------------------------

File: server\Services\Character\CharacterCreationService.cs
Content:
using VitalityBuilder.Domain.Character;
using VitalityBuilder.Domain.Dtos.Character;
using VitalityBuilder.Domain.Errors;
using VitalityBuilder.Infrastructure.Security;
using VitalityBuilder.Interfaces.Services;

namespace VitalityBuilder.Services.Character;

public class CharacterCreationService : ICharacterCreationService
{
    private readonly ICharacterRepository _repository;
    private readonly ICharacterStatCalculator _statCalculator;
    private readonly IPointPoolCalculator _pointCalculator;
    private readonly IValidationService _validationService;
    private readonly ILogger<CharacterCreationService> _logger;

    public CharacterCreationService(
        ICharacterRepository repository,
        ICharacterStatCalculator statCalculator,
        IPointPoolCalculator pointCalculator,
        IValidationService validationService,
        ILogger<CharacterCreationService> logger)
    {
        _repository = repository;
        _statCalculator = statCalculator;
        _pointCalculator = pointCalculator;
        _validationService = validationService;
        _logger = logger;
    }

    public async Task<CharacterResponseDto> CreateCharacterAsync(CreateCharacterDto request)
    {
        try
        {
            // Validate the request
            var validationResult = await _validationService.ValidateCharacterCreation(request);
            if (!validationResult.IsValid)
            {
                _logger.LogWarning("Character creation validation failed: {Errors}", 
                    string.Join(", ", validationResult.Errors));
                throw new ValidationException(validationResult.Errors);
            }

            // Sanitize input
            var sanitizedName = InputSanitizer.SanitizeName(request.Name);

            // Create character entity
            var character = new Domain.Character.Character
            {
                Name = sanitizedName,
                Tier = request.Tier,
                CombatAttributes = new()
                {
                    Focus = request.Focus,
                    Power = request.Power,
                    Mobility = request.Mobility,
                    Endurance = request.Endurance
                },
                UtilityAttributes = new()
                {
                    Awareness = request.Awareness,
                    Communication = request.Communication,
                    Intelligence = request.Intelligence
                },
                Archetypes = new()
                {
                    MovementType = Enum.Parse<MovementArchetype>(request.MovementArchetype),
                    AttackType = Enum.Parse<AttackArchetype>(request.AttackArchetype),
                    EffectType = Enum.Parse<EffectArchetype>(request.EffectArchetype),
                    UniqueAbility = Enum.Parse<UniqueAbilityArchetype>(request.UniqueAbilityArchetype),
                    SpecialAttack = Enum.Parse<SpecialAttackArchetype>(request.SpecialAttackArchetype),
                    UtilityType = Enum.Parse<UtilityArchetype>(request.UtilityArchetype)
                }
            };

            // Calculate initial stats
            var stats = _statCalculator.CalculateAllStats(character);
            var points = _pointCalculator.CalculateAllPools(character);

            // Validate point allocation
            var pointValidation = _pointCalculator.ValidatePointAllocation(character);
            if (!pointValidation.IsValid)
            {
                throw new ValidationException(pointValidation.Errors);
            }

            // Save character
            await _repository.AddCharacterAsync(character);
            await _repository.SaveChangesAsync();

            _logger.LogInformation("Created character {Id} with name {Name}", 
                character.Id, character.Name);

            // Create response DTO
            var response = new CharacterResponseDto
            {
                Id = character.Id,
                Name = character.Name,
                Tier = character.Tier,
                CombatAttributes = new()
                {
                    Focus = character.CombatAttributes.Focus,
                    Power = character.CombatAttributes.Power,
                    Mobility = character.CombatAttributes.Mobility,
                    Endurance = character.CombatAttributes.Endurance,
                    Values = new()
                    {
                        Avoidance = stats.Avoidance,
                        Durability = stats.Durability,
                        ResolveResistance = stats.ResolveResistance,
                        StabilityResistance = stats.StabilityResistance,
                        VitalityResistance = stats.VitalityResistance
                    }
                },
                UtilityAttributes = new()
                {
                    Awareness = character.UtilityAttributes.Awareness,
                    Communication = character.UtilityAttributes.Communication,
                    Intelligence = character.UtilityAttributes.Intelligence
                },
                Archetypes = new()
                {
                    MovementType = character.Archetypes.MovementType.ToString(),
                    AttackType = character.Archetypes.AttackType.ToString(),
                    EffectType = character.Archetypes.EffectType.ToString(),
                    UniqueAbility = character.Archetypes.UniqueAbility.ToString(),
                    SpecialAttack = character.Archetypes.SpecialAttack.ToString(),
                    UtilityType = character.Archetypes.UtilityType.ToString()
                },
                PointPools = new()
                {
                    MainPool = points.MainPool,
                    UtilityPoints = points.UtilityPoints,
                    CombatAttributePoints = points.CombatAttributePoints,
                    UtilityAttributePoints = points.UtilityAttributePoints,
                    SpecialAttackPoints = points.SpecialAttackPoints
                },
                Warnings = pointValidation.Warnings.ToList()
            };

            return response;
        }
        catch (Exception ex) when (ex is not ValidationException)
        {
            _logger.LogError(ex, "Error creating character");
            throw;
        }
    }
}
--------------------------------------------------

File: server\Services\Character\CharacterUpdateService.cs
Content:
using VitalityBuilder.Domain.Character;
using VitalityBuilder.Domain.Dtos.Character;
using VitalityBuilder.Domain.Errors;
using VitalityBuilder.Infrastructure.Security;
using VitalityBuilder.Interfaces.Services;

namespace VitalityBuilder.Services.Character;

public class CharacterUpdateService : ICharacterUpdateService
{
    private readonly ICharacterRepository _repository;
    private readonly ICharacterStatCalculator _statCalculator;
    private readonly IPointPoolCalculator _pointCalculator;
    private readonly IValidationService _validationService;
    private readonly ILogger<CharacterUpdateService> _logger;

    public CharacterUpdateService(
        ICharacterRepository repository,
        ICharacterStatCalculator statCalculator,
        IPointPoolCalculator pointCalculator,
        IValidationService validationService,
        ILogger<CharacterUpdateService> logger)
    {
        _repository = repository;
        _statCalculator = statCalculator;
        _pointCalculator = pointCalculator;
        _validationService = validationService;
        _logger = logger;
    }

    public async Task<CharacterResponseDto> UpdateCharacterAsync(int id, UpdateCharacterDto request)
    {
        try
        {
            // Get existing character
            var character = await _repository.GetCharacterWithDetailsAsync(id);
            if (character == null)
            {
                throw new NotFoundException($"Character with ID {id} not found");
            }

            // Create snapshot for change tracking
            var snapshot = CreateCharacterSnapshot(character);

            // Validate the update request
            var validationResult = await _validationService.ValidateCharacterUpdate(character, request);
            if (!validationResult.IsValid)
            {
                _logger.LogWarning("Character update validation failed: {Errors}", 
                    string.Join(", ", validationResult.Errors));
                throw new ValidationException(validationResult.Errors);
            }

            // Update basic information
            if (!string.IsNullOrWhiteSpace(request.Name))
            {
                character.Name = InputSanitizer.SanitizeName(request.Name);
            }

            // Update tier if changed
            if (request.Tier.HasValue && request.Tier.Value != character.Tier)
            {
                await UpdateCharacterTier(character, request.Tier.Value);
            }

            // Update attributes if provided
            if (request.CombatAttributes != null)
            {
                await UpdateCombatAttributes(character, request.CombatAttributes);
            }

            if (request.UtilityAttributes != null)
            {
                await UpdateUtilityAttributes(character, request.UtilityAttributes);
            }

            // Update archetypes if provided
            if (request.Archetypes != null)
            {
                await UpdateArchetypes(character, request.Archetypes);
            }

            // Recalculate stats
            var stats = _statCalculator.CalculateAllStats(character);
            var points = _pointCalculator.CalculateAllPools(character);

            // Validate final state
            var finalValidation = await ValidateFinalState(character, snapshot);
            if (!finalValidation.IsValid)
            {
                throw new ValidationException(finalValidation.Errors);
            }

            // Save changes
            await _repository.SaveChangesAsync();

            _logger.LogInformation("Updated character {Id}", id);

            // Create response
            return await CreateResponseDto(character, stats, points, finalValidation.Warnings);
        }
        catch (Exception ex) when (ex is not ValidationException && ex is not NotFoundException)
        {
            _logger.LogError(ex, "Error updating character {Id}", id);
            throw;
        }
    }

    private CharacterSnapshot CreateCharacterSnapshot(Domain.Character.Character character)
    {
        return new CharacterSnapshot
        {
            Tier = character.Tier,
            CombatAttributes = character.CombatAttributes.Clone(),
            UtilityAttributes = character.UtilityAttributes.Clone(),
            Archetypes = character.Archetypes.Clone()
        };
    }

    private async Task UpdateCharacterTier(Domain.Character.Character character, int newTier)
    {
        // Validate tier change
        var tierValidation = await _validationService.ValidateTierChange(character, newTier);
        if (!tierValidation.IsValid)
        {
            throw new ValidationException(tierValidation.Errors);
        }

        character.Tier = newTier;
    }

    private async Task UpdateCombatAttributes(Domain.Character.Character character, UpdateCombatAttributesDto attributes)
    {
        // Validate attribute changes
        var attributeValidation = await _validationService.ValidateCombatAttributeUpdate(character, attributes);
        if (!attributeValidation.IsValid)
        {
            throw new ValidationException(attributeValidation.Errors);
        }

        character.CombatAttributes.Focus = attributes.Focus;
        character.CombatAttributes.Power = attributes.Power;
        character.CombatAttributes.Mobility = attributes.Mobility;
        character.CombatAttributes.Endurance = attributes.Endurance;
    }

    private async Task UpdateUtilityAttributes(Domain.Character.Character character, UpdateUtilityAttributesDto attributes)
    {
        // Validate attribute changes
        var attributeValidation = await _validationService.ValidateUtilityAttributeUpdate(character, attributes);
        if (!attributeValidation.IsValid)
        {
            throw new ValidationException(attributeValidation.Errors);
        }

        character.UtilityAttributes.Awareness = attributes.Awareness;
        character.UtilityAttributes.Communication = attributes.Communication;
        character.UtilityAttributes.Intelligence = attributes.Intelligence;
    }

    private async Task UpdateArchetypes(Domain.Character.Character character, UpdateArchetypesDto archetypes)
    {
        // Validate archetype changes
        var archetypeValidation = await _validationService.ValidateArchetypeUpdate(character, archetypes);
        if (!archetypeValidation.IsValid)
        {
            throw new ValidationException(archetypeValidation.Errors);
        }

        character.Archetypes.MovementType = Enum.Parse<MovementArchetype>(archetypes.MovementType);
        character.Archetypes.AttackType = Enum.Parse<AttackArchetype>(archetypes.AttackType);
        character.Archetypes.EffectType = Enum.Parse<EffectArchetype>(archetypes.EffectType);
        character.Archetypes.UniqueAbility = Enum.Parse<UniqueAbilityArchetype>(archetypes.UniqueAbility);
        character.Archetypes.SpecialAttack = Enum.Parse<SpecialAttackArchetype>(archetypes.SpecialAttack);
        character.Archetypes.UtilityType = Enum.Parse<UtilityArchetype>(archetypes.UtilityType);
    }

    private async Task<ValidationResult> ValidateFinalState(
        Domain.Character.Character character, 
        CharacterSnapshot snapshot)
    {
        var result = new ValidationResult();

        // Validate points
        var pointValidation = _pointCalculator.ValidatePointAllocation(character);
        result.AddErrors(pointValidation.Errors);
        result.AddWarnings(pointValidation.Warnings);

        // Validate ability requirements
        var abilityValidation = await _validationService.ValidateAbilityRequirements(character);
        result.AddErrors(abilityValidation.Errors);
        result.AddWarnings(abilityValidation.Warnings);

        // Add warnings for significant changes
        if (character.Tier != snapshot.Tier)
        {
            result.AddWarning($"Character tier changed from {snapshot.Tier} to {character.Tier}");
        }

        return result;
    }

    private async Task<CharacterResponseDto> CreateResponseDto(
        Domain.Character.Character character,
        CombatStats stats,
        PointPools points,
        IEnumerable<string> warnings)
    {
        return new CharacterResponseDto
        {
            Id = character.Id,
            Name = character.Name,
            Tier = character.Tier,
            CombatAttributes = new()
            {
                Focus = character.CombatAttributes.Focus,
                Power = character.CombatAttributes.Power,
                Mobility = character.CombatAttributes.Mobility,
                Endurance = character.CombatAttributes.Endurance,
                Values = new()
                {
                    Avoidance = stats.Avoidance,
                    Durability = stats.Durability,
                    ResolveResistance = stats.ResolveResistance,
                    StabilityResistance = stats.StabilityResistance,
                    VitalityResistance = stats.VitalityResistance
                }
            },
            UtilityAttributes = new()
            {
                Awareness = character.UtilityAttributes.Awareness,
                Communication = character.UtilityAttributes.Communication,
                Intelligence = character.UtilityAttributes.Intelligence
            },
            Archetypes = new()
            {
                MovementType = character.Archetypes.MovementType.ToString(),
                AttackType = character.Archetypes.AttackType.ToString(),
                EffectType = character.Archetypes.EffectType.ToString(),
                UniqueAbility = character.Archetypes.UniqueAbility.ToString(),
                SpecialAttack = character.Archetypes.SpecialAttack.ToString(),
                UtilityType = character.Archetypes.UtilityType.ToString()
            },
            PointPools = new()
            {
                MainPool = points.MainPool,
                UtilityPoints = points.UtilityPoints,
                CombatAttributePoints = points.CombatAttributePoints,
                UtilityAttributePoints = points.UtilityAttributePoints,
                SpecialAttackPoints = points.SpecialAttackPoints
            },
            Warnings = warnings.ToList()
        };
    }
}

public class CharacterSnapshot
{
    public int Tier { get; set; }
    public CombatAttributes CombatAttributes { get; set; } = null!;
    public UtilityAttributes UtilityAttributes { get; set; } = null!;
    public CharacterArchetypes Archetypes { get; set; } = null!;
}
--------------------------------------------------

File: server\Services\Validation\ValidationService.cs
Content:
using FluentValidation;
using VitalityBuilder.Domain.Character;
using VitalityBuilder.Domain.Constants;
using VitalityBuilder.Domain.Dtos.Character;
using VitalityBuilder.Domain.Errors;
using VitalityBuilder.Infrastructure.Validation;

namespace VitalityBuilder.Services.Validation;

public class ValidationService : IValidationService
{
    private readonly ICharacterRepository _repository;
    private readonly IPointPoolCalculator _pointCalculator;
    private readonly ILogger<ValidationService> _logger;

    public ValidationService(
        ICharacterRepository repository,
        IPointPoolCalculator pointCalculator,
        ILogger<ValidationService> logger)
    {
        _repository = repository;
        _pointCalculator = pointCalculator;
        _logger = logger;
    }

    public async Task<ValidationResult> ValidateCharacterCreation(CreateCharacterDto request)
    {
        var result = new ValidationResult();

        // Basic validation using FluentValidation
        var validator = new CharacterValidator();
        var validationResult = await validator.ValidateAsync(request);

        if (!validationResult.IsValid)
        {
            result.AddErrors(validationResult.Errors.Select(e => e.ErrorMessage));
            return result;
        }

        // Validate name uniqueness
        if (await _repository.NameExistsAsync(request.Name))
        {
            result.AddError($"Character name '{request.Name}' is already taken");
            return result;
        }

        // Validate archetype combinations
        var archetypeValidation = ValidateArchetypeCombinations(
            request.AttackArchetype,
            request.EffectArchetype,
            request.MovementArchetype,
            request.SpecialAttackArchetype);

        if (!archetypeValidation.IsValid)
        {
            result.AddErrors(archetypeValidation.Errors);
            return result;
        }

        // Add optimization warnings
        AddOptimizationWarnings(request, result);

        return result;
    }

    public async Task<ValidationResult> ValidateCharacterUpdate(
        Domain.Character.Character character,
        UpdateCharacterDto request)
    {
        var result = new ValidationResult();

        // Validate tier changes
        if (request.Tier.HasValue)
        {
            var tierValidation = ValidateTierChange(character.Tier, request.Tier.Value);
            if (!tierValidation.IsValid)
            {
                result.AddErrors(tierValidation.Errors);
                return result;
            }
        }

        // Validate name changes
        if (!string.IsNullOrWhiteSpace(request.Name) && 
            request.Name != character.Name &&
            await _repository.NameExistsAsync(request.Name))
        {
            result.AddError($"Character name '{request.Name}' is already taken");
            return result;
        }

        // Validate attribute changes
        if (request.CombatAttributes != null)
        {
            var combatValidation = ValidateCombatAttributes(
                request.CombatAttributes,
                request.Tier ?? character.Tier);

            if (!combatValidation.IsValid)
            {
                result.AddErrors(combatValidation.Errors);
                return result;
            }
        }

        if (request.UtilityAttributes != null)
        {
            var utilityValidation = ValidateUtilityAttributes(
                request.UtilityAttributes,
                request.Tier ?? character.Tier);

            if (!utilityValidation.IsValid)
            {
                result.AddErrors(utilityValidation.Errors);
                return result;
            }
        }

        // Add optimization warnings
        if (request.CombatAttributes != null || request.UtilityAttributes != null)
        {
            AddOptimizationWarnings(request, result);
        }

        return result;
    }

    public async Task<ValidationResult> ValidateAbilityRequirements(Domain.Character.Character character)
    {
        var result = new ValidationResult();

        // Validate special attack requirements
        foreach (var attack in character.SpecialAttacks)
        {
            var attackValidation = ValidateSpecialAttackRequirements(attack, character);
            if (!attackValidation.IsValid)
            {
                result.AddErrors(attackValidation.Errors);
            }
        }

        // Validate feature requirements
        foreach (var feature in character.Features)
        {
            var featureValidation = ValidateFeatureRequirements(feature, character);
            if (!featureValidation.IsValid)
            {
                result.AddErrors(featureValidation.Errors);
            }
        }

        // Validate expertise requirements
        foreach (var expertise in character.Expertise)
        {
            var expertiseValidation = ValidateExpertiseRequirements(expertise, character);
            if (!expertiseValidation.IsValid)
            {
                result.AddErrors(expertiseValidation.Errors);
            }
        }

        return result;
    }

    private ValidationResult ValidateArchetypeCombinations(
        string attackType,
        string effectType,
        string movementType,
        string specialAttackType)
    {
        var result = new ValidationResult();

        // Validate incompatible combinations
        if (effectType == "DamageSpecialist" && attackType == "DirectSpecialist")
        {
            result.AddError("Direct Specialist cannot be combined with Damage Specialist");
        }

        // Add warnings for potentially inefficient combinations
        if (attackType == "AOESpecialist" && movementType == "Swift")
        {
            result.AddWarning("AOE Specialist may have limited synergy with Swift movement");
        }

        return result;
    }

    private ValidationResult ValidateTierChange(int currentTier, int newTier)
    {
        var result = new ValidationResult();

        if (newTier < GameRuleConstants.MinimumTier || 
            newTier > GameRuleConstants.MaximumTier)
        {
            result.AddError($"Tier must be between {GameRuleConstants.MinimumTier} and {GameRuleConstants.MaximumTier}");
            return result;
        }

        if (newTier < currentTier)
        {
            result.AddError("Cannot decrease character tier");
            return result;
        }

        if (newTier - currentTier > 1)
        {
            result.AddWarning("Increasing tier by more than one level at once may require additional validation");
        }

        return result;
    }

    private ValidationResult ValidateCombatAttributes(
        UpdateCombatAttributesDto attributes,
        int tier)
    {
        var result = new ValidationResult();

        // Validate individual attributes
        if (attributes.Focus > tier)
            result.AddError($"Focus cannot exceed tier ({tier})");

        if (attributes.Power > tier)
            result.AddError($"Power cannot exceed tier ({tier})");

        if (attributes.Mobility > tier)
            result.AddError($"Mobility cannot exceed tier ({tier})");

        if (attributes.Endurance > tier)
            result.AddError($"Endurance cannot exceed tier ({tier})");

        // Validate total points
        var total = attributes.Focus + attributes.Power + 
                   attributes.Mobility + attributes.Endurance;

        if (total > tier * 2)
            result.AddError($"Total combat attributes cannot exceed {tier * 2} points");

        return result;
    }

    private ValidationResult ValidateUtilityAttributes(
        UpdateUtilityAttributesDto attributes,
        int tier)
    {
        var result = new ValidationResult();

        // Validate individual attributes
        if (attributes.Awareness > tier)
            result.AddError($"Awareness cannot exceed tier ({tier})");

        if (attributes.Communication > tier)
            result.AddError($"Communication cannot exceed tier ({tier})");

        if (attributes.Intelligence > tier)
            result.AddError($"Intelligence cannot exceed tier ({tier})");

        // Validate total points
        var total = attributes.Awareness + attributes.Communication + 
                   attributes.Intelligence;

        if (total > tier)
            result.AddError($"Total utility attributes cannot exceed {tier} points");

        return result;
    }

    private ValidationResult ValidateSpecialAttackRequirements(
        SpecialAttack attack,
        Domain.Character.Character character)
    {
        var result = new ValidationResult();

        // Validate attribute requirements
        switch (attack.AttackType)
        {
            case AttackType.Melee when character.CombatAttributes.Power < 2:
                result.AddError($"Melee attack '{attack.Name}' requires Power 2 or higher");
                break;

            case AttackType.Ranged when character.CombatAttributes.Focus < 2:
                result.AddError($"Ranged attack '{attack.Name}' requires Focus 2 or higher");
                break;
        }

        // Validate point costs
        if (attack.PointCost > character.SpecialAttackPoints)
        {
            result.AddError($"Special attack '{attack.Name}' exceeds available points");
        }

        return result;
    }

    private ValidationResult ValidateFeatureRequirements(
        CharacterFeature feature,
        Domain.Character.Character character)
    {
        var result = new ValidationResult();

        // Validate attribute requirements
        if (feature.MinimumAttribute > 0)
        {
            var attributeValue = GetAttributeValue(character, feature.RequiredAttribute);
            if (attributeValue < feature.MinimumAttribute)
            {
                result.AddError($"Feature '{feature.Name}' requires {feature.RequiredAttribute} {feature.MinimumAttribute} or higher");
            }
        }

        return result;
    }

    private ValidationResult ValidateExpertiseRequirements(
        CharacterExpertise expertise,
        Domain.Character.Character character)
    {
        var result = new ValidationResult();

        // Validate attribute requirements
        var attributeValue = GetAttributeValue(character, expertise.RequiredAttribute);
        if (attributeValue < expertise.MinimumAttribute)
        {
            result.AddError($"Expertise '{expertise.Name}' requires {expertise.RequiredAttribute} {expertise.MinimumAttribute} or higher");
        }

        return result;
    }

    private int GetAttributeValue(Domain.Character.Character character, string attributeName)
    {
        return attributeName.ToLower() switch
        {
            "focus" => character.CombatAttributes.Focus,
            "power" => character.CombatAttributes.Power,
            "mobility" => character.CombatAttributes.Mobility,
            "endurance" => character.CombatAttributes.Endurance,
            "awareness" => character.UtilityAttributes.Awareness,
            "communication" => character.UtilityAttributes.Communication,
            "intelligence" => character.UtilityAttributes.Intelligence,
            _ => throw new ArgumentException($"Unknown attribute: {attributeName}")
        };
    }

    private void AddOptimizationWarnings(dynamic request, ValidationResult result)
    {
        // Check for potentially inefficient combat builds
        if (request.Focus > 0 && request.Power > 0 && request.Mobility > 0)
        {
            result.AddWarning("Spreading points across Focus, Power, and Mobility may reduce combat effectiveness");
        }

        // Check for defensive vulnerabilities
        if (request.Endurance == 0)
        {
            result.AddWarning("Having 0 Endurance may make your character vulnerable in combat");
        }

        // Check for skill check limitations
        if (request.Intelligence == 0 && request.Awareness == 0)
        {
            result.AddWarning("Having 0 in both Intelligence and Awareness may limit non-combat capabilities");
        }
    }
}
--------------------------------------------------

File: server\Interfaces\Repositories\ICharacterRepository.cs
Content:
using VitalityBuilder.Domain.Character;

namespace VitalityBuilder.Interfaces.Repositories;

/// <summary>
/// Repository interface for character data access operations
/// </summary>
public interface ICharacterRepository
{
    /// <summary>
    /// Gets a character by ID
    /// </summary>
    Task<Character?> GetCharacterAsync(int id);

    /// <summary>
    /// Gets a character with all related entities
    /// </summary>
    Task<Character?> GetCharacterWithDetailsAsync(int id);

    /// <summary>
    /// Checks if a character exists
    /// </summary>
    Task<bool> CharacterExistsAsync(int id);

    /// <summary>
    /// Checks if a character name is already taken
    /// </summary>
    Task<bool> NameExistsAsync(string name);

    /// <summary>
    /// Gets characters matching specified criteria
    /// </summary>
    Task<IEnumerable<Character>> GetCharactersAsync(
        int? minTier = null,
        int? maxTier = null,
        string? nameSearch = null,
        int? skip = null,
        int? take = null);

    /// <summary>
    /// Gets the total count of characters matching criteria
    /// </summary>
    Task<int> GetCharacterCountAsync(
        int? minTier = null,
        int? maxTier = null,
        string? nameSearch = null);

    /// <summary>
    /// Adds a new character
    /// </summary>
    Task AddCharacterAsync(Character character);

    /// <summary>
    /// Updates an existing character
    /// </summary>
    void UpdateCharacter(Character character);

    /// <summary>
    /// Marks a character as deleted
    /// </summary>
    Task DeleteCharacterAsync(int id);

    /// <summary>
    /// Gets a character's special attacks
    /// </summary>
    Task<IEnumerable<SpecialAttack>> GetSpecialAttacksAsync(int characterId);

    /// <summary>
    /// Gets a character's features
    /// </summary>
    Task<IEnumerable<CharacterFeature>> GetFeaturesAsync(int characterId);

    /// <summary>
    /// Gets a character's expertise
    /// </summary>
    Task<IEnumerable<CharacterExpertise>> GetExpertiseAsync(int characterId);

    /// <summary>
    /// Checks if a character has specific features
    /// </summary>
    Task<bool> HasFeatureAsync(int characterId, string featureName);

    /// <summary>
    /// Gets characters with point allocations exceeding their tier limits
    /// </summary>
    Task<IEnumerable<Character>> GetCharactersWithExceededPointsAsync();

    /// <summary>
    /// Gets characters with invalid archetype combinations
    /// </summary>
    Task<IEnumerable<Character>> GetCharactersWithInvalidArchetypesAsync();

    /// <summary>
    /// Gets characters that need recalculation due to rule changes
    /// </summary>
    Task<IEnumerable<Character>> GetCharactersNeedingRecalculationAsync();

    /// <summary>
    /// Saves all changes to the database
    /// </summary>
    Task<int> SaveChangesAsync();
}
--------------------------------------------------

File: server\Interfaces\Services\ICharacterStatCalculator.cs
Content:
using VitalityBuilder.Domain.Character;
using VitalityBuilder.Domain.ValueObjects;

namespace VitalityBuilder.Interfaces.Services;

/// <summary>
/// Interface for calculating character statistics and derived values
/// </summary>
public interface ICharacterStatCalculator
{
    /// <summary>
    /// Calculates all combat statistics for a character
    /// </summary>
    CombatStats CalculateAllStats(Character character);

    /// <summary>
    /// Calculates base attack values without archetype modifiers
    /// </summary>
    Task<AttackValues> CalculateBaseAttackValuesAsync(Character character);

    /// <summary>
    /// Calculates modified attack values including archetype effects
    /// </summary>
    Task<AttackValues> CalculateModifiedAttackValuesAsync(
        Character character,
        bool includeTemporaryEffects = false);

    /// <summary>
    /// Calculates defensive values
    /// </summary>
    Task<DefenseValues> CalculateDefenseValuesAsync(Character character);

    /// <summary>
    /// Calculates resistance values against conditions
    /// </summary>
    Task<ResistanceValues> CalculateResistanceValuesAsync(Character character);

    /// <summary>
    /// Calculates movement capabilities
    /// </summary>
    Task<MovementValues> CalculateMovementValuesAsync(Character character);

    /// <summary>
    /// Calculates all initiative-related values
    /// </summary>
    Task<InitiativeValues> CalculateInitiativeValuesAsync(Character character);

    /// <summary>
    /// Calculates derived utility values
    /// </summary>
    Task<UtilityValues> CalculateUtilityValuesAsync(Character character);

    /// <summary>
    /// Validates that all calculated values are within legal limits
    /// </summary>
    Task<ValidationResult> ValidateCalculatedValuesAsync(Character character);
}

public class AttackValues
{
    public int BaseAccuracyBonus { get; set; }
    public int BaseDamageBonus { get; set; }
    public int BaseConditionBonus { get; set; }
    public double CriticalHitChance { get; set; }
    public int SpecialAttackModifier { get; set; }
    public Dictionary<string, int> TypeSpecificBonuses { get; set; } = new();
}

public class DefenseValues
{
    public int BaseAvoidance { get; set; }
    public int ModifiedAvoidance { get; set; }
    public int BaseDurability { get; set; }
    public int ModifiedDurability { get; set; }
    public int DamageReduction { get; set; }
    public Dictionary<string, int> TypeSpecificResistances { get; set; } = new();
}

public class ResistanceValues
{
    public int ResolveResistance { get; set; }
    public int StabilityResistance { get; set; }
    public int VitalityResistance { get; set; }
    public Dictionary<string, int> ConditionImmunities { get; set; } = new();
    public Dictionary<string, double> ResistanceMultipliers { get; set; } = new();
}

public class MovementValues
{
    public int BaseMovementSpeed { get; set; }
    public int ModifiedMovementSpeed { get; set; }
    public bool IgnoresDifficultTerrain { get; set; }
    public bool IgnoresOpportunityAttacks { get; set; }
    public bool CanFly { get; set; }
    public bool CanTeleport { get; set; }
    public int JumpDistance { get; set; }
    public Dictionary<string, double> TerrainMultipliers { get; set; } = new();
}

public class InitiativeValues
{
    public int BaseInitiative { get; set; }
    public int ModifiedInitiative { get; set; }
    public bool AdvantageOnInitiative { get; set; }
    public int BonusToAllies { get; set; }
    public Dictionary<string, int> SituationalBonuses { get; set; } = new();
}

public class UtilityValues
{
    public int DynamicEntryAllies { get; set; }
    public int DynamicEntrySpaces { get; set; }
    public Dictionary<string, int> SkillBonuses { get; set; } = new();
    public Dictionary<string, int> ExpertiseBonuses { get; set; } = new();
    public List<string> SpecialSenses { get; set; } = new();
}
--------------------------------------------------

File: server\Interfaces\Services\IPointPoolCalculator.cs
Content:
using VitalityBuilder.Domain.Character;
using VitalityBuilder.Domain.Errors;

namespace VitalityBuilder.Interfaces.Services;

/// <summary>
/// Interface for calculating and validating character point pools
/// </summary>
public interface IPointPoolCalculator
{
    /// <summary>
    /// Calculates all point pools for a character
    /// </summary>
    Task<PointPools> CalculateAllPoolsAsync(Character character);

    /// <summary>
    /// Calculates special attack points including limit modifiers
    /// </summary>
    Task<SpecialAttackPoints> CalculateSpecialAttackPointsAsync(
        Character character,
        IEnumerable<string> limits);

    /// <summary>
    /// Validates point allocation across all pools
    /// </summary>
    Task<ValidationResult> ValidatePointAllocationAsync(Character character);

    /// <summary>
    /// Checks if a character has sufficient points for a purchase
    /// </summary>
    Task<bool> HasSufficientPointsAsync(
        Character character,
        string poolType,
        int cost);

    /// <summary>
    /// Calculates remaining points in each pool
    /// </summary>
    Task<PointPoolRemaining> CalculateRemainingPointsAsync(Character character);

    /// <summary>
    /// Calculates point costs for a specific purchase
    /// </summary>
    Task<PointCost> CalculatePointCostAsync(
        Character character,
        string purchaseType,
        IDictionary<string, object> parameters);

    /// <summary>
    /// Validates limit point calculations
    /// </summary>
    Task<ValidationResult> ValidateLimitPointsAsync(
        Character character,
        IEnumerable<string> limits);
}

public class PointPools
{
    /// <summary>
    /// Base point pools
    /// </summary>
    public int MainPool { get; set; }
    public int UtilityPoints { get; set; }
    public int CombatAttributePoints { get; set; }
    public int UtilityAttributePoints { get; set; }

    /// <summary>
    /// Special attack points
    /// </summary>
    public int BaseSpecialAttackPoints { get; set; }
    public int BonusSpecialAttackPoints { get; set; }
    public int TotalSpecialAttackPoints => BaseSpecialAttackPoints + BonusSpecialAttackPoints;

    /// <summary>
    /// Point modifiers from archetypes
    /// </summary>
    public double MainPoolMultiplier { get; set; } = 1.0;
    public double UtilityPoolMultiplier { get; set; } = 1.0;
    public double SpecialAttackMultiplier { get; set; } = 1.0;

    /// <summary>
    /// Point tracking
    /// </summary>
    public Dictionary<string, int> SpentPoints { get; set; } = new();
    public Dictionary<string, int> BonusPoints { get; set; } = new();
}

public class SpecialAttackPoints
{
    /// <summary>
    /// Base points from tier
    /// </summary>
    public int BasePoints { get; set; }

    /// <summary>
    /// Points from limits
    /// </summary>
    public int LimitPoints { get; set; }

    /// <summary>
    /// Archetype bonuses
    /// </summary>
    public int ArchetypeBonus { get; set; }

    /// <summary>
    /// Total available points
    /// </summary>
    public int TotalPoints => BasePoints + LimitPoints + ArchetypeBonus;

    /// <summary>
    /// Detail about limit calculations
    /// </summary>
    public Dictionary<string, int> LimitValues { get; set; } = new();
    public Dictionary<string, double> LimitMultipliers { get; set; } = new();
}

public class PointPoolRemaining
{
    /// <summary>
    /// Remaining points in each pool
    /// </summary>
    public int MainPoolRemaining { get; set; }
    public int UtilityPointsRemaining { get; set; }
    public int CombatAttributePointsRemaining { get; set; }
    public int UtilityAttributePointsRemaining { get; set; }
    public int SpecialAttackPointsRemaining { get; set; }

    /// <summary>
    /// Tracking for specific categories
    /// </summary>
    public Dictionary<string, int> CategoryRemaining { get; set; } = new();
    public Dictionary<string, int> UnspentBonusPoints { get; set; } = new();
}

public class PointCost
{
    /// <summary>
    /// Base cost before modifiers
    /// </summary>
    public int BaseCost { get; set; }

    /// <summary>
    /// Modifiers affecting cost
    /// </summary>
    public List<PointCostModifier> Modifiers { get; set; } = new();

    /// <summary>
    /// Final cost after all modifiers
    /// </summary>
    public int FinalCost { get; set; }

    /// <summary>
    /// Pool that points should be spent from
    /// </summary>
    public string PoolType { get; set; } = string.Empty;

    /// <summary>
    /// Whether prerequisites are met
    /// </summary>
    public bool PrerequisitesMet { get; set; }

    /// <summary>
    /// Any warnings about the purchase
    /// </summary>
    public List<string> Warnings { get; set; } = new();
}

public class PointCostModifier
{
    /// <summary>
    /// Source of the modifier
    /// </summary>
    public string Source { get; set; } = string.Empty;

    /// <summary>
    /// Type of modification
    /// </summary>
    public PointModificationType Type { get; set; }

    /// <summary>
    /// Value of the modifier
    /// </summary>
    public double Value { get; set; }

    /// <summary>
    /// Order in which modifier should be applied
    /// </summary>
    public int Priority { get; set; }
}

public enum PointModificationType
{
    Multiplier,
    FlatBonus,
    PercentageDiscount,
    MinimumCost,
    MaximumCost
}
--------------------------------------------------

File: server\Infrastructure\Data\VitalityBuilderContext.cs
Content:
using Microsoft.EntityFrameworkCore;
using VitalityBuilder.Domain.Attributes;
using VitalityBuilder.Domain.Character;
using VitalityBuilder.Infrastructure.Data.Configurations;

namespace VitalityBuilder.Infrastructure.Data;

public class VitalityBuilderContext : DbContext
{
    public VitalityBuilderContext(DbContextOptions<VitalityBuilderContext> options)
        : base(options)
    {
    }

    // Core Entities
    public DbSet<Character> Characters { get; set; } = null!;
    public DbSet<CombatAttributes> CombatAttributes { get; set; } = null!;
    public DbSet<UtilityAttributes> UtilityAttributes { get; set; } = null!;
    public DbSet<CharacterArchetypes> CharacterArchetypes { get; set; } = null!;

    // Collections
    public DbSet<SpecialAttack> SpecialAttacks { get; set; } = null!;
    public DbSet<CharacterFeature> Features { get; set; } = null!;
    public DbSet<CharacterExpertise> Expertise { get; set; } = null!;

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Apply entity configurations
        modelBuilder.ApplyConfiguration(new CharacterConfiguration());
        modelBuilder.ApplyConfiguration(new CombatAttributesConfiguration());
        modelBuilder.ApplyConfiguration(new UtilityAttributesConfiguration());
        modelBuilder.ApplyConfiguration(new CharacterArchetypesConfiguration());

        // Global query filters
        modelBuilder.Entity<Character>()
            .HasQueryFilter(c => !c.IsDeleted);

        // Common properties for all entities
        foreach (var entityType in modelBuilder.Model.GetEntityTypes())
        {
            // Add audit fields if they exist
            if (entityType.FindProperty("CreatedAt") != null)
            {
                modelBuilder.Entity(entityType.Name)
                    .Property("CreatedAt")
                    .HasDefaultValueSql("GETUTCDATE()");
            }

            if (entityType.FindProperty("LastModifiedAt") != null)
            {
                modelBuilder.Entity(entityType.Name)
                    .Property("LastModifiedAt")
                    .HasDefaultValueSql("GETUTCDATE()");
            }

            // Add soft delete if supported
            if (entityType.FindProperty("IsDeleted") != null)
            {
                modelBuilder.Entity(entityType.Name)
                    .Property("IsDeleted")
                    .HasDefaultValue(false);
            }
        }

        // Configure database triggers
        modelBuilder.HasDbFunction(typeof(VitalityBuilderContext)
            .GetMethod(nameof(CalculateCharacterPoints))!)
            .HasName("fn_CalculateCharacterPoints");
    }

    // Database functions
    public int CalculateCharacterPoints(int characterId, string poolType)
        => throw new NotSupportedException();

    // Override SaveChanges to handle audit fields
    public override int SaveChanges()
    {
        UpdateAuditFields();
        return base.SaveChanges();
    }

    public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        UpdateAuditFields();
        return base.SaveChangesAsync(cancellationToken);
    }

    private void UpdateAuditFields()
    {
        var entries = ChangeTracker.Entries()
            .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified);

        var currentTime = DateTime.UtcNow;

        foreach (var entry in entries)
        {
            if (entry.State == EntityState.Added)
            {
                if (entry.Property("CreatedAt")?.CurrentValue == null)
                {
                    entry.Property("CreatedAt").CurrentValue = currentTime;
                }
            }

            if (entry.Property("LastModifiedAt")?.CurrentValue != null)
            {
                entry.Property("LastModifiedAt").CurrentValue = currentTime;
            }
        }
    }

    // Helper methods for common operations
    public async Task<bool> CharacterExistsAsync(int id)
    {
        return await Characters.AnyAsync(c => c.Id == id && !c.IsDeleted);
    }

    public IQueryable<Character> GetCharactersWithRelated()
    {
        return Characters
            .Include(c => c.CombatAttributes)
            .Include(c => c.UtilityAttributes)
            .Include(c => c.Archetypes)
            .Include(c => c.SpecialAttacks)
            .Include(c => c.Features)
            .Include(c => c.Expertise)
            .AsSplitQuery(); // Split into multiple SQL queries for better performance
    }
}
--------------------------------------------------

File: server\Infrastructure\Security\InputSanitizer.cs
Content:
using System.Text.RegularExpressions;

namespace VitalityBuilder.Infrastructure.Security;

/// <summary>
/// Provides input sanitization for user-provided data
/// </summary>
public static class InputSanitizer
{
    // Common patterns for validation
    private static readonly Regex ValidNamePattern = new(@"^[a-zA-Z0-9\s\-']{1,100}$", RegexOptions.Compiled);
    private static readonly Regex ValidDescriptionPattern = new(@"^[a-zA-Z0-9\s\-'.,!?()]{1,1000}$", RegexOptions.Compiled);
    private static readonly Regex ScriptPattern = new(@"<script.*?>.*?</script>", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Singleline);
    private static readonly Regex HtmlTagPattern = new(@"<[^>]*>", RegexOptions.Compiled);
    private static readonly Regex SqlInjectionPattern = new(@"(\b(ALTER|CREATE|DELETE|DROP|EXEC(UTE){0,1}|INSERT( +INTO){0,1}|MERGE|SELECT|UPDATE|UNION( +ALL){0,1})\b)", RegexOptions.Compiled | RegexOptions.IgnoreCase);

    /// <summary>
    /// Sanitizes a character name
    /// </summary>
    public static string SanitizeName(string? input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return string.Empty;
        }

        // Trim and normalize spaces
        var sanitized = NormalizeWhitespace(input);

        // Ensure it matches our valid pattern
        if (!ValidNamePattern.IsMatch(sanitized))
        {
            // Remove any invalid characters
            sanitized = Regex.Replace(sanitized, @"[^a-zA-Z0-9\s\-']", "");
        }

        return sanitized.Length > 100 ? sanitized[..100] : sanitized;
    }

    /// <summary>
    /// Sanitizes a description or longer text field
    /// </summary>
    public static string SanitizeDescription(string? input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return string.Empty;
        }

        // Remove potential XSS attempts
        var sanitized = RemoveScriptTags(input);

        // Remove HTML tags
        sanitized = RemoveHtmlTags(sanitized);

        // Normalize whitespace
        sanitized = NormalizeWhitespace(sanitized);

        // Ensure it matches our valid pattern
        if (!ValidDescriptionPattern.IsMatch(sanitized))
        {
            // Remove any invalid characters
            sanitized = Regex.Replace(sanitized, @"[^a-zA-Z0-9\s\-'.,!?()]", "");
        }

        return sanitized.Length > 1000 ? sanitized[..1000] : sanitized;
    }

    /// <summary>
    /// Sanitizes input that will be used in SQL queries
    /// </summary>
    public static string SanitizeSqlInput(string? input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return string.Empty;
        }

        // Check for potential SQL injection attempts
        if (SqlInjectionPattern.IsMatch(input))
        {
            throw new ArgumentException("Potential SQL injection detected");
        }

        // Replace single quotes with double single quotes
        return input.Replace("'", "''");
    }

    /// <summary>
    /// Validates and sanitizes an enumeration value
    /// </summary>
    public static string SanitizeEnum<T>(string? input) where T : Enum
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return string.Empty;
        }

        // Remove any non-alphanumeric characters
        var sanitized = Regex.Replace(input, @"[^a-zA-Z0-9]", "");

        // Verify it's a valid enum value
        if (Enum.TryParse(typeof(T), sanitized, true, out _))
        {
            return sanitized;
        }

        throw new ArgumentException($"Invalid value for enum type {typeof(T).Name}");
    }

    /// <summary>
    /// Normalizes whitespace in a string
    /// </summary>
    private static string NormalizeWhitespace(string input)
    {
        // Replace multiple spaces with a single space
        var normalized = Regex.Replace(input.Trim(), @"\s+", " ");

        // Remove any control characters
        return Regex.Replace(normalized, @"[\x00-\x1F\x7F]", "");
    }

    /// <summary>
    /// Removes script tags from input
    /// </summary>
    private static string RemoveScriptTags(string input)
    {
        // Remove script tags and their contents
        return ScriptPattern.Replace(input, "");
    }

    /// <summary>
    /// Removes HTML tags from input
    /// </summary>
    private static string RemoveHtmlTags(string input)
    {
        // Remove HTML tags but keep their contents
        return HtmlTagPattern.Replace(input, "");
    }

    /// <summary>
    /// Checks if a string might contain malicious content
    /// </summary>
    public static bool ContainsSuspiciousContent(string input)
    {
        // Check for script tags
        if (ScriptPattern.IsMatch(input))
        {
            return true;
        }

        // Check for SQL injection attempts
        if (SqlInjectionPattern.IsMatch(input))
        {
            return true;
        }

        // Check for potential shell commands
        if (input.Contains('&') || input.Contains('|') || input.Contains(';'))
        {
            return true;
        }

        return false;
    }

    /// <summary>
    /// Validates and sanitizes a file path
    /// </summary>
    public static string SanitizeFilePath(string? input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return string.Empty;
        }

        // Remove any directory traversal attempts
        var sanitized = input.Replace("..", "");

        // Remove any characters that aren't valid in file paths
        sanitized = Regex.Replace(sanitized, @"[^\w\-./\\]", "");

        return sanitized;
    }
}
--------------------------------------------------

File: server\Infrastructure\Validation\CharacterValidator.cs
Content:
using FluentValidation;
using VitalityBuilder.Domain.Constants;
using VitalityBuilder.Domain.Dtos.Character;

namespace VitalityBuilder.Infrastructure.Validation;

public class CharacterValidator : AbstractValidator<CharacterBasicDto>
{
    public CharacterValidator()
    {
        // Name Validation
        RuleFor(x => x.Name)
            .NotEmpty()
            .WithMessage("Character name is required")
            .Length(1, 100)
            .WithMessage("Name must be between 1 and 100 characters")
            .Must(name => !name.Contains("  "))
            .WithMessage("Name cannot contain consecutive spaces")
            .Matches("^[a-zA-Z0-9\\s\\-']*$")
            .WithMessage("Name can only contain letters, numbers, spaces, hyphens, and apostrophes");

        // Tier Validation
        RuleFor(x => x.Tier)
            .InclusiveBetween(GameRuleConstants.MinimumTier, GameRuleConstants.MaximumTier)
            .WithMessage($"Tier must be between {GameRuleConstants.MinimumTier} and {GameRuleConstants.MaximumTier}");

        // Combat Attributes
        RuleFor(x => x)
            .Must(ValidateCombatAttributeTotal)
            .WithMessage(x => $"Total combat attributes cannot exceed {x.Tier * 2} points");

        RuleFor(x => x.Focus)
            .Must((character, focus) => focus <= character.Tier)
            .WithMessage(x => $"Focus cannot exceed character tier ({x.Tier})");

        RuleFor(x => x.Power)
            .Must((character, power) => power <= character.Tier)
            .WithMessage(x => $"Power cannot exceed character tier ({x.Tier})");

        RuleFor(x => x.Mobility)
            .Must((character, mobility) => mobility <= character.Tier)
            .WithMessage(x => $"Mobility cannot exceed character tier ({x.Tier})");

        RuleFor(x => x.Endurance)
            .Must((character, endurance) => endurance <= character.Tier)
            .WithMessage(x => $"Endurance cannot exceed character tier ({x.Tier})");

        // Utility Attributes
        RuleFor(x => x)
            .Must(ValidateUtilityAttributeTotal)
            .WithMessage(x => $"Total utility attributes cannot exceed {x.Tier} points");

        RuleFor(x => x.Awareness)
            .Must((character, awareness) => awareness <= character.Tier)
            .WithMessage(x => $"Awareness cannot exceed character tier ({x.Tier})");

        RuleFor(x => x.Communication)
            .Must((character, communication) => communication <= character.Tier)
            .WithMessage(x => $"Communication cannot exceed character tier ({x.Tier})");

        RuleFor(x => x.Intelligence)
            .Must((character, intelligence) => intelligence <= character.Tier)
            .WithMessage(x => $"Intelligence cannot exceed character tier ({x.Tier})");

        // Archetype Validation
        RuleFor(x => x.MovementArchetype)
            .NotEmpty()
            .WithMessage("Movement archetype is required")
            .Must(BeValidArchetype)
            .WithMessage("Invalid movement archetype selected");

        RuleFor(x => x.AttackArchetype)
            .NotEmpty()
            .WithMessage("Attack archetype is required")
            .Must(BeValidArchetype)
            .WithMessage("Invalid attack archetype selected");

        RuleFor(x => x.EffectArchetype)
            .NotEmpty()
            .WithMessage("Effect archetype is required")
            .Must(BeValidArchetype)
            .WithMessage("Invalid effect archetype selected");

        RuleFor(x => x.UniqueAbilityArchetype)
            .NotEmpty()
            .WithMessage("Unique ability archetype is required")
            .Must(BeValidArchetype)
            .WithMessage("Invalid unique ability archetype selected");

        RuleFor(x => x.SpecialAttackArchetype)
            .NotEmpty()
            .WithMessage("Special attack archetype is required")
            .Must(BeValidArchetype)
            .WithMessage("Invalid special attack archetype selected");

        RuleFor(x => x.UtilityArchetype)
            .NotEmpty()
            .WithMessage("Utility archetype is required")
            .Must(BeValidArchetype)
            .WithMessage("Invalid utility archetype selected");
    }

    private bool ValidateCombatAttributeTotal(CharacterBasicDto character)
    {
        var total = character.Focus + character.Power + 
                   character.Mobility + character.Endurance;
        return total <= character.Tier * 2;
    }

    private bool ValidateUtilityAttributeTotal(CharacterBasicDto character)
    {
        var total = character.Awareness + character.Communication + 
                   character.Intelligence;
        return total <= character.Tier;
    }

    private bool BeValidArchetype(string archetype)
    {
        // Add specific archetype validation logic based on your enums
        return !string.IsNullOrWhiteSpace(archetype) && 
               archetype.All(c => char.IsLetterOrDigit(c) || c == '_');
    }
}
--------------------------------------------------

File: server\Infrastructure\Validation\CombatAttributesValidator.cs
Content:
using FluentValidation;
using VitalityBuilder.Domain.Constants;
using VitalityBuilder.Domain.Dtos.Character;

namespace VitalityBuilder.Infrastructure.Validation;

public class CharacterValidator : AbstractValidator<CharacterBasicDto>
{
    public CharacterValidator()
    {
        // Name Validation
        RuleFor(x => x.Name)
            .NotEmpty()
            .WithMessage("Character name is required")
            .Length(1, 100)
            .WithMessage("Name must be between 1 and 100 characters")
            .Must(name => !name.Contains("  "))
            .WithMessage("Name cannot contain consecutive spaces")
            .Matches("^[a-zA-Z0-9\\s\\-']*$")
            .WithMessage("Name can only contain letters, numbers, spaces, hyphens, and apostrophes");

        // Tier Validation
        RuleFor(x => x.Tier)
            .InclusiveBetween(GameRuleConstants.MinimumTier, GameRuleConstants.MaximumTier)
            .WithMessage($"Tier must be between {GameRuleConstants.MinimumTier} and {GameRuleConstants.MaximumTier}");

        // Combat Attributes
        RuleFor(x => x)
            .Must(ValidateCombatAttributeTotal)
            .WithMessage(x => $"Total combat attributes cannot exceed {x.Tier * 2} points");

        RuleFor(x => x.Focus)
            .Must((character, focus) => focus <= character.Tier)
            .WithMessage(x => $"Focus cannot exceed character tier ({x.Tier})");

        RuleFor(x => x.Power)
            .Must((character, power) => power <= character.Tier)
            .WithMessage(x => $"Power cannot exceed character tier ({x.Tier})");

        RuleFor(x => x.Mobility)
            .Must((character, mobility) => mobility <= character.Tier)
            .WithMessage(x => $"Mobility cannot exceed character tier ({x.Tier})");

        RuleFor(x => x.Endurance)
            .Must((character, endurance) => endurance <= character.Tier)
            .WithMessage(x => $"Endurance cannot exceed character tier ({x.Tier})");

        // Utility Attributes
        RuleFor(x => x)
            .Must(ValidateUtilityAttributeTotal)
            .WithMessage(x => $"Total utility attributes cannot exceed {x.Tier} points");

        RuleFor(x => x.Awareness)
            .Must((character, awareness) => awareness <= character.Tier)
            .WithMessage(x => $"Awareness cannot exceed character tier ({x.Tier})");

        RuleFor(x => x.Communication)
            .Must((character, communication) => communication <= character.Tier)
            .WithMessage(x => $"Communication cannot exceed character tier ({x.Tier})");

        RuleFor(x => x.Intelligence)
            .Must((character, intelligence) => intelligence <= character.Tier)
            .WithMessage(x => $"Intelligence cannot exceed character tier ({x.Tier})");

        // Archetype Validation
        RuleFor(x => x.MovementArchetype)
            .NotEmpty()
            .WithMessage("Movement archetype is required")
            .Must(BeValidArchetype)
            .WithMessage("Invalid movement archetype selected");

        RuleFor(x => x.AttackArchetype)
            .NotEmpty()
            .WithMessage("Attack archetype is required")
            .Must(BeValidArchetype)
            .WithMessage("Invalid attack archetype selected");

        RuleFor(x => x.EffectArchetype)
            .NotEmpty()
            .WithMessage("Effect archetype is required")
            .Must(BeValidArchetype)
            .WithMessage("Invalid effect archetype selected");

        RuleFor(x => x.UniqueAbilityArchetype)
            .NotEmpty()
            .WithMessage("Unique ability archetype is required")
            .Must(BeValidArchetype)
            .WithMessage("Invalid unique ability archetype selected");

        RuleFor(x => x.SpecialAttackArchetype)
            .NotEmpty()
            .WithMessage("Special attack archetype is required")
            .Must(BeValidArchetype)
            .WithMessage("Invalid special attack archetype selected");

        RuleFor(x => x.UtilityArchetype)
            .NotEmpty()
            .WithMessage("Utility archetype is required")
            .Must(BeValidArchetype)
            .WithMessage("Invalid utility archetype selected");
    }

    private bool ValidateCombatAttributeTotal(CharacterBasicDto character)
    {
        var total = character.Focus + character.Power + 
                   character.Mobility + character.Endurance;
        return total <= character.Tier * 2;
    }

    private bool ValidateUtilityAttributeTotal(CharacterBasicDto character)
    {
        var total = character.Awareness + character.Communication + 
                   character.Intelligence;
        return total <= character.Tier;
    }

    private bool BeValidArchetype(string archetype)
    {
        // Add specific archetype validation logic based on your enums
        return !string.IsNullOrWhiteSpace(archetype) && 
               archetype.All(c => char.IsLetterOrDigit(c) || c == '_');
    }
}
--------------------------------------------------

File: server\Infrastructure\Validation\UtilityAttributesValidator.cs
Content:
using FluentValidation;
using VitalityBuilder.Domain.Constants;
using VitalityBuilder.Domain.Dtos.Attributes;

namespace VitalityBuilder.Infrastructure.Validation;

public class UtilityAttributesValidator : AbstractValidator<UtilityAttributesDto>
{
    private readonly int _characterTier;

    public UtilityAttributesValidator(int characterTier)
    {
        _characterTier = characterTier;

        // Validate Awareness
        RuleFor(x => x.Awareness)
            .InclusiveBetween(0, _characterTier)
            .WithMessage($"Awareness must be between 0 and {_characterTier}");

        // Validate Communication
        RuleFor(x => x.Communication)
            .InclusiveBetween(0, _characterTier)
            .WithMessage($"Communication must be between 0 and {_characterTier}");

        // Validate Intelligence
        RuleFor(x => x.Intelligence)
            .InclusiveBetween(0, _characterTier)
            .WithMessage($"Intelligence must be between 0 and {_characterTier}");

        // Validate Total Points
        RuleFor(x => x)
            .Must(ValidateTotalPoints)
            .WithMessage($"Total utility attributes cannot exceed {_characterTier} points");

        // Validate Available Points
        RuleFor(x => x)
            .Must(ValidatePointsSpent)
            .WithMessage(x => $"Cannot spend more than {x.AvailablePoints} points");

        // Expertise Validations
        RuleFor(x => x)
            .Must(ValidateExpertiseRequirements)
            .WithMessage("Utility attributes do not meet expertise requirements");

        // Feature Validations
        RuleFor(x => x)
            .Must(ValidateFeatureRequirements)
            .WithMessage("Utility attributes do not meet feature requirements");

        // Context-specific validation rules
        When(x => x.Values.SkillBonuses.Any(), () =>
        {
            RuleFor(x => x)
                .Must(ValidateSkillBonusRequirements)
                .WithMessage("Skill bonus requirements not met");
        });
    }

    private bool ValidateTotalPoints(UtilityAttributesDto attributes)
    {
        return attributes.TotalPoints <= _characterTier;
    }

    private bool ValidatePointsSpent(UtilityAttributesDto attributes)
    {
        return attributes.TotalPoints <= attributes.AvailablePoints;
    }

    private bool ValidateExpertiseRequirements(UtilityAttributesDto attributes)
    {
        foreach (var skillBonus in attributes.Values.SkillBonuses)
        {
            // Get the required attribute value for this expertise
            var requiredValue = GetRequiredAttributeValue(skillBonus.AttributeName);
            var actualValue = GetAttributeValue(attributes, skillBonus.AttributeName);

            if (actualValue < requiredValue)
            {
                return false;
            }
        }
        return true;
    }

    private bool ValidateFeatureRequirements(UtilityAttributesDto attributes)
    {
        // Add specific feature validation logic
        // This would check if attributes meet minimum requirements for chosen features
        return true;
    }

    private bool ValidateSkillBonusRequirements(UtilityAttributesDto attributes)
    {
        // Add specific skill bonus validation logic
        // This would ensure skill bonuses don't exceed game rules
        return true;
    }

    private int GetRequiredAttributeValue(string attributeName)
    {
        // Define minimum attribute requirements for expertise
        return attributeName.ToLower() switch
        {
            "awareness" => 2,
            "communication" => 2,
            "intelligence" => 2,
            _ => throw new ArgumentException($"Unknown attribute: {attributeName}")
        };
    }

    private int GetAttributeValue(UtilityAttributesDto attributes, string attributeName)
    {
        return attributeName.ToLower() switch
        {
            "awareness" => attributes.Awareness,
            "communication" => attributes.Communication,
            "intelligence" => attributes.Intelligence,
            _ => throw new ArgumentException($"Unknown attribute: {attributeName}")
        };
    }

    /// <summary>
    /// Creates utility attribute warnings without failing validation
    /// </summary>
    public IEnumerable<string> GenerateWarnings(UtilityAttributesDto attributes)
    {
        var warnings = new List<string>();

        // Check for unspent points
        if (attributes.RemainingPoints > 0)
        {
            warnings.Add($"You have {attributes.RemainingPoints} unspent utility attribute points");
        }

        // Check for potential skill gaps
        if (attributes.Awareness == 0)
        {
            warnings.Add("Having 0 Awareness may make your character vulnerable to surprises and reduce initiative");
        }

        if (attributes.Communication == 0)
        {
            warnings.Add("Having 0 Communication may limit your character's social interactions");
        }

        if (attributes.Intelligence == 0)
        {
            warnings.Add("Having 0 Intelligence may limit your character's problem-solving capabilities");
        }

        // Check for specialized build warnings
        if (attributes.Awareness >= _characterTier &&
            attributes.Communication == 0 &&
            attributes.Intelligence == 0)
        {
            warnings.Add("Highly specialized in Awareness - consider diversifying for better utility");
        }

        if (attributes.Communication >= _characterTier &&
            attributes.Awareness == 0 &&
            attributes.Intelligence == 0)
        {
            warnings.Add("Highly specialized in Communication - consider diversifying for better utility");
        }

        if (attributes.Intelligence >= _characterTier &&
            attributes.Awareness == 0 &&
            attributes.Communication == 0)
        {
            warnings.Add("Highly specialized in Intelligence - consider diversifying for better utility");
        }

        // Check for expertise-related warnings
        foreach (var skillBonus in attributes.Values.SkillBonuses)
        {
            var attributeValue = GetAttributeValue(attributes, skillBonus.AttributeName);
            if (attributeValue == 1 && skillBonus.ExpertiseBonus > 0)
            {
                warnings.Add($"Low {skillBonus.AttributeName} value may limit the effectiveness of related expertise");
            }
        }

        // Dynamic Entry warnings
        if (attributes.Intelligence == 1)
        {
            warnings.Add("Minimum Intelligence limits Dynamic Entry to only one ally");
        }

        if (attributes.Communication == 1)
        {
            warnings.Add("Minimum Communication limits Dynamic Entry range");
        }

        return warnings;
    }
}
--------------------------------------------------

File: server\Infrastructure\Data\Configurations\CharacterConfiguration.cs
Content:
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using VitalityBuilder.Domain.Character;
using VitalityBuilder.Domain.Constants;

namespace VitalityBuilder.Infrastructure.Data.Configurations;

public class CharacterConfiguration : IEntityTypeConfiguration<Character>
{
    public void Configure(EntityTypeBuilder<Character> builder)
    {
        // Primary Key
        builder.HasKey(c => c.Id);

        // Basic Properties
        builder.Property(c => c.Name)
            .IsRequired()
            .HasMaxLength(100);

        builder.Property(c => c.Tier)
            .IsRequired()
            .HasDefaultValue(GameRuleConstants.MinimumTier);

        // Default Values
        builder.Property(c => c.HealthPool)
            .IsRequired()
            .HasDefaultValue(GameRuleConstants.BaseHealthPool);

        // Combat Attributes Relationship
        builder.HasOne(c => c.CombatAttributes)
            .WithOne(ca => ca.Character)
            .HasForeignKey<CombatAttributes>(ca => ca.CharacterId)
            .OnDelete(DeleteBehavior.Cascade);

        // Utility Attributes Relationship
        builder.HasOne(c => c.UtilityAttributes)
            .WithOne(ua => ua.Character)
            .HasForeignKey<UtilityAttributes>(ua => ua.CharacterId)
            .OnDelete(DeleteBehavior.Cascade);

        // Archetypes Relationship
        builder.HasOne(c => c.Archetypes)
            .WithOne(a => a.Character)
            .HasForeignKey<CharacterArchetypes>(a => a.CharacterId)
            .OnDelete(DeleteBehavior.Cascade);

        // Special Attacks Collection
        builder.HasMany(c => c.SpecialAttacks)
            .WithOne()
            .HasForeignKey("CharacterId")
            .OnDelete(DeleteBehavior.Cascade);

        // Features Collection
        builder.HasMany(c => c.Features)
            .WithOne()
            .HasForeignKey("CharacterId")
            .OnDelete(DeleteBehavior.Cascade);

        // Expertise Collection
        builder.HasMany(c => c.Expertise)
            .WithOne()
            .HasForeignKey("CharacterId")
            .OnDelete(DeleteBehavior.Cascade);

        // Computed Properties
        builder.Property(c => c.MainPool)
            .HasComputedColumnSql("(([Tier] - 2) * 15)");

        builder.Property(c => c.UtilityPoints)
            .HasComputedColumnSql("(5 * ([Tier] - 1))");

        builder.Property(c => c.CombatAttributePoints)
            .HasComputedColumnSql("([Tier] * 2)");

        builder.Property(c => c.UtilityAttributePoints)
            .HasComputedColumnSql("[Tier]");

        // Indexes
        builder.HasIndex(c => c.Name);

        // Query Filters
        builder.HasQueryFilter(c => c.Tier >= GameRuleConstants.MinimumTier);

        // Validation
        builder.HasCheckConstraint("CK_Character_Tier", 
            $"Tier >= {GameRuleConstants.MinimumTier} AND Tier <= {GameRuleConstants.MaximumTier}");

        builder.HasCheckConstraint("CK_Character_HealthPool",
            $"HealthPool >= 0");

        // Value Conversions
        builder.Property<int>("SpentMainPoints")
            .HasDefaultValue(0);

        builder.Property<int>("SpentUtilityPoints")
            .HasDefaultValue(0);

        // Shadow Properties
        builder.Property<DateTime>("CreatedAt")
            .HasDefaultValueSql("GETUTCDATE()");

        builder.Property<DateTime>("LastModifiedAt")
            .HasDefaultValueSql("GETUTCDATE()");

        // Triggers
        builder.ToTable(t => t.HasTrigger("TR_Character_UpdateModifiedDate"));
    }
}
--------------------------------------------------

File: server\Infrastructure\Data\Configurations\CombatAttributesConfiguration.cs
Content:
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using VitalityBuilder.Domain.Attributes;
using VitalityBuilder.Domain.Constants;

namespace VitalityBuilder.Infrastructure.Data.Configurations;

public class CombatAttributesConfiguration : IEntityTypeConfiguration<CombatAttributes>
{
    public void Configure(EntityTypeBuilder<CombatAttributes> builder)
    {
        // Primary Key
        builder.HasKey(ca => ca.Id);

        // Required Character Relationship
        builder.HasOne(ca => ca.Character)
            .WithOne(c => c.CombatAttributes)
            .HasForeignKey<CombatAttributes>(ca => ca.CharacterId)
            .IsRequired()
            .OnDelete(DeleteBehavior.Cascade);

        // Core Attributes
        builder.Property(ca => ca.Focus)
            .IsRequired()
            .HasDefaultValue(0);

        builder.Property(ca => ca.Power)
            .IsRequired()
            .HasDefaultValue(0);

        builder.Property(ca => ca.Mobility)
            .IsRequired()
            .HasDefaultValue(0);

        builder.Property(ca => ca.Endurance)
            .IsRequired()
            .HasDefaultValue(0);

        // Computed Total Points
        builder.Property<int>("TotalPoints")
            .HasComputedColumnSql(
                "[Focus] + [Power] + [Mobility] + [Endurance]", 
                stored: true);

        // Ensure attributes don't exceed tier
        builder.HasCheckConstraint("CK_CombatAttributes_Focus",
            "Focus >= 0 AND Focus <= (SELECT Tier FROM Characters WHERE Id = CharacterId)");

        builder.HasCheckConstraint("CK_CombatAttributes_Power",
            "Power >= 0 AND Power <= (SELECT Tier FROM Characters WHERE Id = CharacterId)");

        builder.HasCheckConstraint("CK_CombatAttributes_Mobility",
            "Mobility >= 0 AND Mobility <= (SELECT Tier FROM Characters WHERE Id = CharacterId)");

        builder.HasCheckConstraint("CK_CombatAttributes_Endurance",
            "Endurance >= 0 AND Endurance <= (SELECT Tier FROM Characters WHERE Id = CharacterId)");

        // Ensure total points don't exceed tier × 2
        builder.HasCheckConstraint("CK_CombatAttributes_TotalPoints",
            "([Focus] + [Power] + [Mobility] + [Endurance]) <= (SELECT Tier * 2 FROM Characters WHERE Id = CharacterId)");

        // Computed Columns for Derived Stats
        builder.Property<int>("Avoidance")
            .HasComputedColumnSql(
                "10 + (SELECT Tier FROM Characters WHERE Id = CharacterId) + [Mobility]",
                stored: true);

        builder.Property<int>("Durability")
            .HasComputedColumnSql(
                "(SELECT Tier FROM Characters WHERE Id = CharacterId) + CEILING(CAST([Endurance] as float) * 1.5)",
                stored: true);

        builder.Property<int>("ResolveResistance")
            .HasComputedColumnSql(
                "10 + (SELECT Tier FROM Characters WHERE Id = CharacterId) + [Focus]",
                stored: true);

        builder.Property<int>("StabilityResistance")
            .HasComputedColumnSql(
                "10 + (SELECT Tier FROM Characters WHERE Id = CharacterId) + [Power]",
                stored: true);

        builder.Property<int>("VitalityResistance")
            .HasComputedColumnSql(
                "10 + (SELECT Tier FROM Characters WHERE Id = CharacterId) + [Endurance]",
                stored: true);

        // Indexes for Common Queries
        builder.HasIndex(ca => new { ca.CharacterId, ca.Focus });
        builder.HasIndex(ca => new { ca.CharacterId, ca.Power });
        builder.HasIndex(ca => new { ca.CharacterId, ca.Mobility });
        builder.HasIndex(ca => new { ca.CharacterId, ca.Endurance });

        // Querying Helpers
        builder.HasQueryFilter(ca => 
            ca.Focus >= 0 && ca.Power >= 0 && 
            ca.Mobility >= 0 && ca.Endurance >= 0);

        // Audit Fields
        builder.Property<DateTime>("CreatedAt")
            .HasDefaultValueSql("GETUTCDATE()");

        builder.Property<DateTime>("LastModifiedAt")
            .HasDefaultValueSql("GETUTCDATE()");

        // Update Trigger
        builder.ToTable(t => t.HasTrigger("TR_CombatAttributes_UpdateModifiedDate"));
    }
}
--------------------------------------------------

File: server\Infrastructure\Data\Configurations\UtilityAttributesConfiguration.cs
Content:
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using VitalityBuilder.Domain.Attributes;
using VitalityBuilder.Domain.Constants;

namespace VitalityBuilder.Infrastructure.Data.Configurations;

public class UtilityAttributesConfiguration : IEntityTypeConfiguration<UtilityAttributes>
{
    public void Configure(EntityTypeBuilder<UtilityAttributes> builder)
    {
        // Primary Key
        builder.HasKey(ua => ua.Id);

        // Required Character Relationship
        builder.HasOne(ua => ua.Character)
            .WithOne(c => c.UtilityAttributes)
            .HasForeignKey<UtilityAttributes>(ua => ua.CharacterId)
            .IsRequired()
            .OnDelete(DeleteBehavior.Cascade);

        // Core Attributes
        builder.Property(ua => ua.Awareness)
            .IsRequired()
            .HasDefaultValue(0);

        builder.Property(ua => ua.Communication)
            .IsRequired()
            .HasDefaultValue(0);

        builder.Property(ua => ua.Intelligence)
            .IsRequired()
            .HasDefaultValue(0);

        // Computed Total Points
        builder.Property<int>("TotalPoints")
            .HasComputedColumnSql(
                "[Awareness] + [Communication] + [Intelligence]", 
                stored: true);

        // Ensure attributes don't exceed tier
        builder.HasCheckConstraint("CK_UtilityAttributes_Awareness",
            "Awareness >= 0 AND Awareness <= (SELECT Tier FROM Characters WHERE Id = CharacterId)");

        builder.HasCheckConstraint("CK_UtilityAttributes_Communication",
            "Communication >= 0 AND Communication <= (SELECT Tier FROM Characters WHERE Id = CharacterId)");

        builder.HasCheckConstraint("CK_UtilityAttributes_Intelligence",
            "Intelligence >= 0 AND Intelligence <= (SELECT Tier FROM Characters WHERE Id = CharacterId)");

        // Ensure total points don't exceed tier
        builder.HasCheckConstraint("CK_UtilityAttributes_TotalPoints",
            "([Awareness] + [Communication] + [Intelligence]) <= (SELECT Tier FROM Characters WHERE Id = CharacterId)");

        // Computed Columns for Derived Stats
        builder.Property<int>("InitiativeBonus")
            .HasComputedColumnSql("[Awareness]", stored: true);

        builder.Property<int>("DynamicEntryAllies")
            .HasComputedColumnSql(
                "CASE WHEN [Intelligence] < 1 THEN 1 ELSE [Intelligence] END",
                stored: true);

        builder.Property<int>("DynamicEntrySpaces")
            .HasComputedColumnSql(
                "CASE WHEN [Communication] < 1 THEN 1 ELSE [Communication] END",
                stored: true);

        // Indexes for Common Queries
        builder.HasIndex(ua => new { ua.CharacterId, ua.Awareness });
        builder.HasIndex(ua => new { ua.CharacterId, ua.Communication });
        builder.HasIndex(ua => new { ua.CharacterId, ua.Intelligence });

        // Query Filters
        builder.HasQueryFilter(ua => 
            ua.Awareness >= 0 && 
            ua.Communication >= 0 && 
            ua.Intelligence >= 0);

        // Value Conversions
        builder.Property<string>("SkillBonuses")
            .HasConversion(
                v => string.Join(";", v),
                v => v.Split(";", StringSplitOptions.RemoveEmptyEntries));

        // Audit Fields
        builder.Property<DateTime>("CreatedAt")
            .HasDefaultValueSql("GETUTCDATE()");

        builder.Property<DateTime>("LastModifiedAt")
            .HasDefaultValueSql("GETUTCDATE()");

        // Update Trigger
        builder.ToTable(t => t.HasTrigger("TR_UtilityAttributes_UpdateModifiedDate"));

        // Additional Metadata
        builder.HasMetadata("AttributeType", "Utility");
        builder.HasMetadata("MaxTotalPoints", "Tier");
        builder.HasMetadata("AllowsExpertise", "true");
    }
}
--------------------------------------------------

File: server\Domain\Attributes\CombatAttributesEntity.cs
Content:
using System.ComponentModel.DataAnnotations;
using VitalityBuilder.Domain.Character;

namespace VitalityBuilder.Domain.Attributes;

public class CombatAttributes
{
    public int Id { get; set; }

    public int CharacterId { get; set; }
    public Character Character { get; set; } = null!;

    [Range(0, 10)]
    public int Focus { get; set; }

    [Range(0, 10)]
    public int Power { get; set; }

    [Range(0, 10)]
    public int Mobility { get; set; }

    [Range(0, 10)]
    public int Endurance { get; set; }

    /// <summary>
    /// Gets the total number of points spent on combat attributes
    /// </summary>
    public int TotalPoints => Focus + Power + Mobility + Endurance;

    /// <summary>
    /// Validates if the attributes are within the character's tier limits
    /// </summary>
    public bool ValidateAgainstTier(int characterTier)
    {
        // Individual attributes cannot exceed character tier
        if (Focus > characterTier || Power > characterTier || 
            Mobility > characterTier || Endurance > characterTier)
        {
            return false;
        }

        // Total points cannot exceed tier × 2
        if (TotalPoints > characterTier * 2)
        {
            return false;
        }

        return true;
    }

    /// <summary>
    /// Calculates the character's Avoidance score
    /// </summary>
    public int CalculateAvoidance(int characterTier)
    {
        return 10 + characterTier + Mobility;
    }

    /// <summary>
    /// Calculates the character's Durability score
    /// </summary>
    public int CalculateDurability(int characterTier)
    {
        return characterTier + (int)Math.Ceiling(Endurance * 1.5);
    }

    /// <summary>
    /// Calculates the character's Resolve Resistance
    /// </summary>
    public int CalculateResolveResistance(int characterTier)
    {
        return 10 + characterTier + Focus;
    }

    /// <summary>
    /// Calculates the character's Stability Resistance
    /// </summary>
    public int CalculateStabilityResistance(int characterTier)
    {
        return 10 + characterTier + Power;
    }

    /// <summary>
    /// Calculates the character's Vitality Resistance
    /// </summary>
    public int CalculateVitalityResistance(int characterTier)
    {
        return 10 + characterTier + Endurance;
    }

    /// <summary>
    /// Calculates base damage bonus for attacks
    /// </summary>
    public int CalculateDamageBonus(int characterTier)
    {
        return characterTier + (int)Math.Ceiling(Power * 1.5);
    }

    /// <summary>
    /// Calculates movement speed based on mobility
    /// </summary>
    public int CalculateMovementSpeed(int characterTier)
    {
        return Math.Max(6 + Mobility, Mobility + characterTier);
    }

    /// <summary>
    /// Creates a deep copy of the combat attributes
    /// </summary>
    public CombatAttributes Clone()
    {
        return new CombatAttributes
        {
            Focus = Focus,
            Power = Power,
            Mobility = Mobility,
            Endurance = Endurance,
            CharacterId = CharacterId
        };
    }
}
--------------------------------------------------

File: server\Domain\Attributes\UtilityAttributesEntity.cs
Content:
using System.ComponentModel.DataAnnotations;
using VitalityBuilder.Domain.Character;

namespace VitalityBuilder.Domain.Attributes;

public class UtilityAttributes
{
    public int Id { get; set; }

    public int CharacterId { get; set; }
    public Character Character { get; set; } = null!;

    [Range(0, 10)]
    public int Awareness { get; set; }

    [Range(0, 10)]
    public int Communication { get; set; }

    [Range(0, 10)]
    public int Intelligence { get; set; }

    /// <summary>
    /// Gets the total number of points spent on utility attributes
    /// </summary>
    public int TotalPoints => Awareness + Communication + Intelligence;

    /// <summary>
    /// Validates if the attributes are within the character's tier limits
    /// </summary>
    public bool ValidateAgainstTier(int characterTier)
    {
        // Individual attributes cannot exceed character tier
        if (Awareness > characterTier || Communication > characterTier || 
            Intelligence > characterTier)
        {
            return false;
        }

        // Total points cannot exceed tier
        if (TotalPoints > characterTier)
        {
            return false;
        }

        return true;
    }

    /// <summary>
    /// Calculates Initiative bonus based on Awareness
    /// </summary>
    public int CalculateInitiativeBonus()
    {
        return Awareness;
    }

    /// <summary>
    /// Calculates the number of Dynamic Entry allies that can be affected
    /// Based on Intelligence score, minimum of 1
    /// </summary>
    public int CalculateDynamicEntryAllies()
    {
        return Math.Max(1, Intelligence);
    }

    /// <summary>
    /// Calculates the number of Dynamic Entry spaces
    /// Based on Communication score, minimum of 1
    /// </summary>
    public int CalculateDynamicEntrySpaces()
    {
        return Math.Max(1, Communication);
    }

    /// <summary>
    /// Performs a standard skill check for the given attribute
    /// </summary>
    /// <param name="attributeName">The name of the attribute to check</param>
    /// <param name="expertiseBonus">Any additional expertise bonuses</param>
    /// <returns>The total skill check result</returns>
    public (int Total, int[] DiceRolls) PerformSkillCheck(
        string attributeName, 
        int expertiseBonus = 0)
    {
        // Roll 3d6 for skill checks
        var random = new Random();
        var diceRolls = new int[3];
        var total = 0;

        // Roll dice and handle exploding 6s
        for (int i = 0; i < 3; i++)
        {
            var roll = random.Next(1, 7);
            diceRolls[i] = roll;
            total += roll;

            // Handle exploding 6s
            while (roll == 6)
            {
                roll = random.Next(1, 7);
                total += roll;
            }
        }

        // Add attribute bonus
        var attributeBonus = attributeName.ToLower() switch
        {
            "awareness" => Awareness,
            "communication" => Communication,
            "intelligence" => Intelligence,
            _ => throw new ArgumentException($"Unknown attribute: {attributeName}")
        };

        total += attributeBonus + expertiseBonus;

        return (total, diceRolls);
    }

    /// <summary>
    /// Creates a deep copy of the utility attributes
    /// </summary>
    public UtilityAttributes Clone()
    {
        return new UtilityAttributes
        {
            Awareness = Awareness,
            Communication = Communication,
            Intelligence = Intelligence,
            CharacterId = CharacterId
        };
    }
}
--------------------------------------------------

File: server\Domain\Character\Character.cs
Content:
using System.ComponentModel.DataAnnotations;
using VitalityBuilder.Domain.Attributes;
using VitalityBuilder.Domain.ValueObjects;

namespace VitalityBuilder.Domain.Character;

public class Character
{
    public int Id { get; set; }

    [Required]
    [StringLength(100)]
    public string Name { get; set; } = string.Empty;

    [Range(2, 10)]
    public int Tier { get; set; }

    // Core attributes
    public CombatAttributes CombatAttributes { get; set; } = null!;
    public UtilityAttributes UtilityAttributes { get; set; } = null!;
    public CharacterArchetypes Archetypes { get; set; } = null!;

    // Base stats
    public int HealthPool { get; private set; } = 100;
    public int EffortUses { get; private set; } = 2;

    // Point pools
    public int MainPool => (Tier - 2) * 15;
    public int UtilityPoints => 5 * (Tier - 1);
    public int CombatAttributePoints => Tier * 2;
    public int UtilityAttributePoints => Tier;

    // Navigation properties
    public ICollection<SpecialAttack> SpecialAttacks { get; set; } = new List<SpecialAttack>();
    public ICollection<CharacterFeature> Features { get; set; } = new List<CharacterFeature>();
    public ICollection<CharacterExpertise> Expertise { get; set; } = new List<CharacterExpertise>();

    // Point tracking
    public int SpentMainPoints { get; private set; }
    public int SpentUtilityPoints { get; private set; }

    /// <summary>
    /// Calculates derived combat statistics based on current attributes and tier
    /// </summary>
    public CombatStats CalculateCombatStats()
    {
        return new CombatStats
        {
            Avoidance = CombatAttributes.CalculateAvoidance(Tier),
            Durability = CombatAttributes.CalculateDurability(Tier),
            ResolveResistance = CombatAttributes.CalculateResolveResistance(Tier),
            StabilityResistance = CombatAttributes.CalculateStabilityResistance(Tier),
            VitalityResistance = CombatAttributes.CalculateVitalityResistance(Tier),
            MovementSpeed = CalculateMovementSpeed(),
            Initiative = CalculateInitiative()
        };
    }

    /// <summary>
    /// Calculates total movement speed including archetype modifiers
    /// </summary>
    public int CalculateMovementSpeed()
    {
        var baseSpeed = CombatAttributes.CalculateMovementSpeed(Tier);
        return Archetypes.ApplyMovementModifiers(baseSpeed, Tier, CombatAttributes.Endurance);
    }

    /// <summary>
    /// Calculates initiative bonus including all modifiers
    /// </summary>
    public int CalculateInitiative()
    {
        return CombatAttributes.Focus + UtilityAttributes.Awareness;
    }

    /// <summary>
    /// Spends points from the main pool
    /// </summary>
    /// <returns>True if points were successfully spent</returns>
    public bool SpendMainPoints(int amount)
    {
        if (SpentMainPoints + amount > MainPool)
        {
            return false;
        }

        SpentMainPoints += amount;
        return true;
    }

    /// <summary>
    /// Spends points from the utility pool
    /// </summary>
    /// <returns>True if points were successfully spent</returns>
    public bool SpendUtilityPoints(int amount)
    {
        if (SpentUtilityPoints + amount > UtilityPoints)
        {
            return false;
        }

        SpentUtilityPoints += amount;
        return true;
    }

    /// <summary>
    /// Uses an effort and returns success status
    /// </summary>
    public bool UseEffort()
    {
        if (EffortUses <= 0)
        {
            return false;
        }

        EffortUses--;
        return true;
    }

    /// <summary>
    /// Resets effort uses after a rest
    /// </summary>
    public void ResetEffort()
    {
        EffortUses = 2;
    }

    /// <summary>
    /// Validates core combat attribute distribution
    /// </summary>
    public bool ValidateCombatAttributes()
    {
        if (CombatAttributes == null)
        {
            return false;
        }

        return CombatAttributes.ValidateAgainstTier(Tier);
    }

    /// <summary>
    /// Validates core utility attribute distribution
    /// </summary>
    public bool ValidateUtilityAttributes()
    {
        if (UtilityAttributes == null)
        {
            return false;
        }

        return UtilityAttributes.ValidateAgainstTier(Tier);
    }

    /// <summary>
    /// Validates that archetypes are properly selected and compatible
    /// </summary>
    public bool ValidateArchetypes()
    {
        if (Archetypes == null)
        {
            return false;
        }

        return Archetypes.ValidateArchetypes();
    }

    /// <summary>
    /// Performs a survival check when reaching 0 health
    /// </summary>
    /// <param name="excessDamage">Amount of damage that exceeded current health</param>
    /// <returns>True if the character survives</returns>
    public (bool Survived, bool Critical) PerformSurvivalCheck(int excessDamage)
    {
        var random = new Random();
        var roll = random.Next(1, 21); // d20 roll

        if (roll == 20) // Natural 20 always succeeds
        {
            return (true, true);
        }

        // Add Endurance to roll for characters with high vitality
        roll += CombatAttributes.Endurance;

        return (roll >= excessDamage, false);
    }

    /// <summary>
    /// Creates a deep copy of the character
    /// </summary>
    public Character Clone()
    {
        var clone = new Character
        {
            Name = Name,
            Tier = Tier,
            HealthPool = HealthPool,
            EffortUses = EffortUses,
            SpentMainPoints = SpentMainPoints,
            SpentUtilityPoints = SpentUtilityPoints,
            CombatAttributes = CombatAttributes.Clone(),
            UtilityAttributes = UtilityAttributes.Clone(),
            Archetypes = Archetypes.Clone()
        };

        foreach (var attack in SpecialAttacks)
        {
            clone.SpecialAttacks.Add(attack.Clone());
        }

        foreach (var feature in Features)
        {
            clone.Features.Add(feature.Clone());
        }

        foreach (var expertise in Expertise)
        {
            clone.Expertise.Add(expertise.Clone());
        }

        return clone;
    }
}
--------------------------------------------------

File: server\Domain\Character\CharacterArchetypes.cs
Content:
using VitalityBuilder.Domain.Enums;

namespace VitalityBuilder.Domain.Character;

public class CharacterArchetypes
{
    public int Id { get; set; }

    public int CharacterId { get; set; }
    public Character Character { get; set; } = null!;

    // Core archetypes
    public MovementArchetype MovementType { get; set; }
    public AttackArchetype AttackType { get; set; }
    public EffectArchetype EffectType { get; set; }
    public UniqueAbilityArchetype UniqueAbility { get; set; }
    public SpecialAttackArchetype SpecialAttack { get; set; }
    public UtilityArchetype UtilityType { get; set; }

    /// <summary>
    /// Validates that all required archetypes are selected and compatible
    /// </summary>
    public bool ValidateArchetypes()
    {
        // Ensure all archetypes are selected
        if (!Enum.IsDefined(typeof(MovementArchetype), MovementType) ||
            !Enum.IsDefined(typeof(AttackArchetype), AttackType) ||
            !Enum.IsDefined(typeof(EffectArchetype), EffectType) ||
            !Enum.IsDefined(typeof(UniqueAbilityArchetype), UniqueAbility) ||
            !Enum.IsDefined(typeof(SpecialAttackArchetype), SpecialAttack) ||
            !Enum.IsDefined(typeof(UtilityArchetype), UtilityType))
        {
            return false;
        }

        // Add any specific incompatibility checks here
        return ValidateArchetypeCompatibility();
    }

    /// <summary>
    /// Checks for any archetype combinations that are not allowed
    /// </summary>
    private bool ValidateArchetypeCompatibility()
    {
        // Example compatibility check
        if (EffectType == EffectArchetype.DamageSpecialist &&
            AttackType == AttackArchetype.DirectSpecialist)
        {
            return false; // Direct attacks cannot be damage-only
        }

        return true;
    }

    /// <summary>
    /// Calculates movement speed modifications based on movement archetype
    /// </summary>
    public int ApplyMovementModifiers(int baseSpeed, int tier, int endurance)
    {
        return MovementType switch
        {
            MovementArchetype.Swift => baseSpeed + (int)Math.Ceiling(tier / 2.0),
            MovementArchetype.Vanguard => baseSpeed + endurance,
            MovementArchetype.Flight => baseSpeed,
            MovementArchetype.Portal => baseSpeed - 2,
            MovementArchetype.SuperJump => baseSpeed + (tier >= 7 ? 2 : 1),
            MovementArchetype.Swinging => baseSpeed + (tier >= 7 ? 2 : 1),
            _ => baseSpeed
        };
    }

    /// <summary>
    /// Applies attack archetype modifiers to accuracy rolls
    /// </summary>
    public int ApplyAttackModifiers(int baseAccuracy, int tier)
    {
        return AttackType switch
        {
            AttackArchetype.AOESpecialist => baseAccuracy - tier,
            _ => baseAccuracy
        };
    }

    /// <summary>
    /// Applies effect archetype modifiers to damage and condition rolls
    /// </summary>
    public (int Damage, int Condition) ApplyEffectModifiers(int baseDamage, int baseCondition, int tier)
    {
        return EffectType switch
        {
            EffectArchetype.HybridSpecialist => (baseDamage - tier, baseCondition - tier),
            EffectArchetype.CrowdControl => (baseDamage - tier, baseCondition),
            _ => (baseDamage, baseCondition)
        };
    }

    /// <summary>
    /// Gets the number of special attacks allowed based on archetype
    /// </summary>
    public int GetSpecialAttackLimit(int tier)
    {
        return SpecialAttack switch
        {
            SpecialAttackArchetype.OneSpell => 1,
            SpecialAttackArchetype.DualNatured => 2,
            _ => tier
        };
    }

    /// <summary>
    /// Calculates special attack points based on archetype and limits
    /// </summary>
    public int CalculateSpecialAttackPoints(int tier, int limitPoints)
    {
        return SpecialAttack switch
        {
            SpecialAttackArchetype.Paragon => 10 * tier,
            SpecialAttackArchetype.OneTrick => 20 * tier,
            SpecialAttackArchetype.DualNatured => 15 * tier,
            SpecialAttackArchetype.Basic => 10 * tier,
            SpecialAttackArchetype.SharedUses => 10 * tier - limitPoints,
            _ => limitPoints
        };
    }

    /// <summary>
    /// Gets utility point multiplier based on archetype
    /// </summary>
    public double GetUtilityPointMultiplier()
    {
        return UtilityType switch
        {
            UtilityArchetype.Specialized => 0.8, // (5 × [Tier-2])
            UtilityArchetype.JackOfAllTrades => 0.8, // (5 × [Tier-2])
            _ => 1.0 // Practical: (5 × [Tier-1])
        };
    }

    /// <summary>
    /// Creates a deep copy of the archetypes
    /// </summary>
    public CharacterArchetypes Clone()
    {
        return new CharacterArchetypes
        {
            MovementType = MovementType,
            AttackType = AttackType,
            EffectType = EffectType,
            UniqueAbility = UniqueAbility,
            SpecialAttack = SpecialAttack,
            UtilityType = UtilityType,
            CharacterId = CharacterId
        };
    }
}
--------------------------------------------------

File: server\Domain\Constants\GameRuleConstants.cs
Content:
namespace VitalityBuilder.Domain.Constants;

public static class GameRuleConstants
{
    // Character Limits
    public const int MinimumTier = 2;
    public const int MaximumTier = 10;
    public const int BaseHealthPool = 100;
    public const int MaxEffortPerSession = 2;
    
    // Attribute Rules
    public const int BaseMovementSpeed = 6;
    public const double EnduranceMultiplier = 1.5;
    public const int BaseResistanceValue = 10;
    
    // Point Calculations
    public const int UtilityPointsPerTier = 5;
    public const int CombatAttributePointsMultiplier = 2;
    
    // Combat Rules
    public const int CriticalHitThreshold = 20;
    public const int BaseDamageRoll = 3; // Number of d6
    public const int BaseAccuracyRoll = 1; // Number of d20
    public const int FallingDamageThreshold = 6; // Spaces
    public const int FallingDamageBase = 1; // Base d6
    
    // Pool Calculations
    public static int CalculateMainPool(int tier) => (tier - 2) * 15;
    public static int CalculateUtilityPoints(int tier) => 5 * (tier - 1);
    public static int CalculateCombatAttributePoints(int tier) => tier * 2;
    public static int CalculateUtilityAttributePoints(int tier) => tier;
    
    // Movement Rules
    public const int BaseJumpDistance = 1;
    public const int JumpDCMultiplier = 5;
    public const int SwimmingMovementCost = 2;
    public const int ClimbingMovementCost = 3;
    public const int FallingSpacesPerTurn = 18;
    
    // Healing Rules
    public const int RestHealingPerHour = 10;
    
    // Special Attack Calculations
    public static class SpecialAttackLimits
    {
        public static int CalculateFullValueLimit(int tier) => tier * 10;
        public static int CalculateHalfValueLimit(int tier) => tier * 20;
        public static double FullValueMultiplier = 1.0;
        public static double HalfValueMultiplier = 0.5;
        public static double QuarterValueMultiplier = 0.25;
    }
    
    // Resistance Values
    public static class ResistanceTypes
    {
        public const string Resolve = "Resolve";
        public const string Stability = "Stability";
        public const string Vitality = "Vitality";
    }
    
    // Validation Messages
    public static class ValidationMessages
    {
        public const string TierOutOfRange = "Character tier must be between {0} and {1}";
        public const string AttributeExceedsTier = "{0} cannot exceed character tier";
        public const string TotalAttributesExceedLimit = "Total {0} attributes cannot exceed {1}";
        public const string InsufficientPoints = "Insufficient points in {0} pool";
        public const string RequiredArchetype = "Must select a {0} archetype";
        public const string IncompatibleArchetypes = "Selected archetypes are not compatible";
    }
    
    // Combat Condition Rules
    public static class CombatConditions
    {
        public const int ExhaustedMovementPenalty = 2; // Halved movement
        public const int AdjacentAttackBonus = 5; // Against prone targets
        public const int RangedAttackPenalty = -5; // Against prone targets
        public const int ProneMovementCost = 3; // Spaces to stand up
    }
    
    // Skill Check Rules
    public static class SkillChecks
    {
        public const int CriticalSuccessThreshold = 20;
        public const int MaxExpertiseStack = 2;
        
        public static class DifficultyClass
        {
            public const int Simple = 10;
            public const int Easy = 15;
            public const int Moderate = 20;
            public const int Challenging = 25;
            public const int VeryDifficult = 30;
            public const int ExtremelyDifficult = 35;
            public const int NearlyImpossible = 40;
        }
    }
}
--------------------------------------------------

File: server\Domain\Enums\ArchetypeEnums.cs
Content:
namespace VitalityBuilder.Api.Models.Enums;

public enum MovementArchetypeType
{
    Swift,
    Skirmisher,
    ParkourRunner,
    Behemoth,
    Bulwark,
    Vanguard,
    Mole,
    Flight,
    Teleportation,
    Portal,
    Swinging,
    SuperJump
}

public enum AttackTypeArchetypeCategory
{
    AOESpecialist,
    DirectSpecialist,
    SingleTarget
}

public enum EffectTypeCategory
{
    DamageSpecialist,
    HybridSpecialist,
    CrowdControl
}

public enum UniqueAbilityCategory
{
    VersatileMaster,
    Extraordinary,
    CutAbove
}

public enum SpecialAttackCategory
{
    Normal,
    Specialist,
    Paragon,
    OneTrick,
    Straightforward,
    SharedUses,
    DualNatured,
    Basic
}

public enum UtilityCategory
{
    Specialized,
    Practical,
    JackOfAllTrades
}
--------------------------------------------------

File: server\Domain\Errors\ErrorResponse.cs
Content:
namespace VitalityBuilder.Domain.Errors;

/// <summary>
/// Standardized error response for API endpoints
/// </summary>
public class ErrorResponse
{
    /// <summary>
    /// Type of error that occurred
    /// </summary>
    public string Type { get; set; } = "Error";

    /// <summary>
    /// Human-readable error message
    /// </summary>
    public string Message { get; set; } = string.Empty;

    /// <summary>
    /// Unique error code for tracking
    /// </summary>
    public string? Code { get; set; }

    /// <summary>
    /// Detailed error information
    /// </summary>
    public ICollection<string> Details { get; set; } = new List<string>();

    /// <summary>
    /// Additional data relevant to the error
    /// </summary>
    public IDictionary<string, object>? Data { get; set; }

    /// <summary>
    /// Creates a validation error response
    /// </summary>
    public static ErrorResponse ValidationError(string message, IEnumerable<string> details)
    {
        return new ErrorResponse
        {
            Type = "ValidationError",
            Message = message,
            Details = details.ToList()
        };
    }

    /// <summary>
    /// Creates a not found error response
    /// </summary>
    public static ErrorResponse NotFound(string resource, string identifier)
    {
        return new ErrorResponse
        {
            Type = "NotFound",
            Message = $"{resource} with identifier {identifier} was not found",
            Code = "404"
        };
    }

    /// <summary>
    /// Creates a business rule violation error response
    /// </summary>
    public static ErrorResponse BusinessRuleViolation(string message, IEnumerable<string> details)
    {
        return new ErrorResponse
        {
            Type = "BusinessRuleViolation",
            Message = message,
            Details = details.ToList()
        };
    }

    /// <summary>
    /// Creates an internal server error response
    /// </summary>
    public static ErrorResponse InternalError(string message, string? code = null)
    {
        return new ErrorResponse
        {
            Type = "InternalError",
            Message = message,
            Code = code ?? "500"
        };
    }

    /// <summary>
    /// Creates an invalid operation error response
    /// </summary>
    public static ErrorResponse InvalidOperation(string message, IEnumerable<string>? details = null)
    {
        return new ErrorResponse
        {
            Type = "InvalidOperation",
            Message = message,
            Details = details?.ToList() ?? new List<string>()
        };
    }
}
--------------------------------------------------

File: server\Domain\Errors\ValidationResults.cs
Content:
namespace VitalityBuilder.Domain.Errors;

/// <summary>
/// Represents the result of a validation operation
/// </summary>
public class ValidationResult
{
    /// <summary>
    /// Whether the validation passed
    /// </summary>
    public bool IsValid => !Errors.Any();

    /// <summary>
    /// Collection of validation errors
    /// </summary>
    public ICollection<string> Errors { get; set; } = new List<string>();

    /// <summary>
    /// Collection of validation warnings
    /// </summary>
    public ICollection<string> Warnings { get; set; } = new List<string>();

    /// <summary>
    /// Additional validation data
    /// </summary>
    public IDictionary<string, object> Data { get; set; } = new Dictionary<string, object>();

    /// <summary>
    /// Creates a successful validation result
    /// </summary>
    public static ValidationResult Success()
    {
        return new ValidationResult();
    }

    /// <summary>
    /// Creates a failed validation result with errors
    /// </summary>
    public static ValidationResult Failure(params string[] errors)
    {
        return new ValidationResult
        {
            Errors = errors.ToList()
        };
    }

    /// <summary>
    /// Creates a successful validation result with warnings
    /// </summary>
    public static ValidationResult WithWarnings(params string[] warnings)
    {
        return new ValidationResult
        {
            Warnings = warnings.ToList()
        };
    }

    /// <summary>
    /// Adds an error to the validation result
    /// </summary>
    public ValidationResult AddError(string error)
    {
        Errors.Add(error);
        return this;
    }

    /// <summary>
    /// Adds multiple errors to the validation result
    /// </summary>
    public ValidationResult AddErrors(IEnumerable<string> errors)
    {
        foreach (var error in errors)
        {
            Errors.Add(error);
        }
        return this;
    }

    /// <summary>
    /// Adds a warning to the validation result
    /// </summary>
    public ValidationResult AddWarning(string warning)
    {
        Warnings.Add(warning);
        return this;
    }

    /// <summary>
    /// Adds multiple warnings to the validation result
    /// </summary>
    public ValidationResult AddWarnings(IEnumerable<string> warnings)
    {
        foreach (var warning in warnings)
        {
            Warnings.Add(warning);
        }
        return this;
    }

    /// <summary>
    /// Adds additional data to the validation result
    /// </summary>
    public ValidationResult AddData(string key, object value)
    {
        Data[key] = value;
        return this;
    }

    /// <summary>
    /// Combines multiple validation results into one
    /// </summary>
    public static ValidationResult Combine(params ValidationResult[] results)
    {
        var combined = new ValidationResult();

        foreach (var result in results)
        {
            combined.AddErrors(result.Errors);
            combined.AddWarnings(result.Warnings);
            foreach (var kvp in result.Data)
            {
                combined.Data[kvp.Key] = kvp.Value;
            }
        }

        return combined;
    }

    /// <summary>
    /// Creates an attribute validation result
    /// </summary>
    public static ValidationResult FromAttributeValidation(
        bool isValid, 
        int availablePoints, 
        int spentPoints, 
        int maxPerAttribute)
    {
        var result = new ValidationResult();

        if (!isValid)
        {
            result.AddError($"Attributes exceed maximum value of {maxPerAttribute}");
        }

        if (spentPoints > availablePoints)
        {
            result.AddError($"Insufficient points: spent {spentPoints}, available {availablePoints}");
        }
        else if (spentPoints < availablePoints)
        {
            result.AddWarning($"Unspent points: {availablePoints - spentPoints} remaining");
        }

        result.AddData("AvailablePoints", availablePoints);
        result.AddData("SpentPoints", spentPoints);
        result.AddData("RemainingPoints", availablePoints - spentPoints);

        return result;
    }

    /// <summary>
    /// Creates an archetype validation result
    /// </summary>
    public static ValidationResult FromArchetypeValidation(
        bool hasRequiredArchetypes,
        bool isCompatible,
        IEnumerable<string>? incompatibilities = null)
    {
        var result = new ValidationResult();

        if (!hasRequiredArchetypes)
        {
            result.AddError("All archetypes must be selected");
        }

        if (!isCompatible)
        {
            result.AddError("Selected archetypes are not compatible");
            if (incompatibilities != null)
            {
                foreach (var incompatibility in incompatibilities)
                {
                    result.AddError(incompatibility);
                }
            }
        }

        return result;
    }
}
--------------------------------------------------

File: server\Domain\ValueObjects\CombatStats.cs
Content:
using VitalityBuilder.Domain.Constants;

namespace VitalityBuilder.Domain.ValueObjects;

/// <summary>
/// Represents derived combat statistics for a character
/// </summary>
public class CombatStats
{
    // Core Defense Values
    public int Avoidance { get; set; }
    public int Durability { get; set; }
    public int MovementSpeed { get; set; }

    // Combat Values
    public int Initiative { get; set; }
    public int BaseAccuracyBonus { get; set; }
    public int BaseDamageBonus { get; set; }
    public int BaseConditionBonus { get; set; }

    // Resistances
    public int ResolveResistance { get; set; }
    public int StabilityResistance { get; set; }
    public int VitalityResistance { get; set; }

    // Status Tracking
    public bool IsExhausted { get; set; }
    public bool IsStealthed { get; set; }
    public bool IsProne { get; set; }

    // Movement Calculations
    public int GetEffectiveMovementSpeed()
    {
        var speed = MovementSpeed;

        if (IsExhausted)
        {
            speed /= 2;
        }

        return Math.Max(1, speed); // Minimum 1 space of movement
    }

    // Attack Modifications
    public int GetAccuracyForAttack(bool isMelee, bool targetIsProne)
    {
        var accuracy = BaseAccuracyBonus;

        if (targetIsProne)
        {
            if (isMelee)
            {
                accuracy += GameRuleConstants.CombatConditions.AdjacentAttackBonus;
            }
            else
            {
                accuracy += GameRuleConstants.CombatConditions.RangedAttackPenalty;
            }
        }

        return accuracy;
    }

    // Defense Calculations
    public int GetEffectiveAvoidance(bool isBeingFlanked)
    {
        var avoidance = Avoidance;

        if (IsProne)
        {
            avoidance -= 2;
        }

        if (isBeingFlanked)
        {
            avoidance -= 2;
        }

        return Math.Max(5, avoidance); // Minimum avoidance of 5
    }

    // Damage Reduction
    public int ReduceDamage(int incomingDamage)
    {
        return Math.Max(0, incomingDamage - Durability);
    }

    // Condition Resistance
    public int GetResistanceForType(string resistanceType)
    {
        return resistanceType.ToLower() switch
        {
            "resolve" => ResolveResistance,
            "stability" => StabilityResistance,
            "vitality" => VitalityResistance,
            _ => throw new ArgumentException($"Unknown resistance type: {resistanceType}")
        };
    }

    // Clone Method
    public CombatStats Clone()
    {
        return new CombatStats
        {
            Avoidance = Avoidance,
            Durability = Durability,
            MovementSpeed = MovementSpeed,
            Initiative = Initiative,
            BaseAccuracyBonus = BaseAccuracyBonus,
            BaseDamageBonus = BaseDamageBonus,
            BaseConditionBonus = BaseConditionBonus,
            ResolveResistance = ResolveResistance,
            StabilityResistance = StabilityResistance,
            VitalityResistance = VitalityResistance,
            IsExhausted = IsExhausted,
            IsStealthed = IsStealthed,
            IsProne = IsProne
        };
    }
}
--------------------------------------------------

File: server\Domain\Dtos\Archetypes\CharacterArchetypesDto.cs
Content:
using System.ComponentModel.DataAnnotations;

namespace VitalityBuilder.Domain.Dtos.Archetypes;

/// <summary>
/// Data transfer object for character archetype selections
/// </summary>
public class CharacterArchetypesDto
{
    [Required(ErrorMessage = "Movement archetype is required")]
    public string MovementType { get; set; } = string.Empty;

    [Required(ErrorMessage = "Attack archetype is required")]
    public string AttackType { get; set; } = string.Empty;

    [Required(ErrorMessage = "Effect archetype is required")]
    public string EffectType { get; set; } = string.Empty;

    [Required(ErrorMessage = "Unique ability archetype is required")]
    public string UniqueAbility { get; set; } = string.Empty;

    [Required(ErrorMessage = "Special attack archetype is required")]
    public string SpecialAttack { get; set; } = string.Empty;

    [Required(ErrorMessage = "Utility archetype is required")]
    public string UtilityType { get; set; } = string.Empty;

    // Calculated modifiers based on archetype combinations
    public ArchetypeModifiersDto Modifiers { get; set; } = new();

    // Point calculations for special attacks
    public ArchetypePointsDto Points { get; set; } = new();

    // Validation state
    public ArchetypeValidationDto Validation { get; set; } = new();
}

/// <summary>
/// Contains all archetype-based modifiers for character calculations
/// </summary>
public class ArchetypeModifiersDto
{
    // Movement Modifiers
    public int MovementSpeedModifier { get; set; }
    public bool IgnoreOpportunityAttacks { get; set; }
    public bool IgnoreTerrainPenalties { get; set; }
    public bool ImmuneToProne { get; set; }
    public int AttackReachBonus { get; set; }

    // Attack Modifiers
    public int AccuracyModifier { get; set; }
    public bool BypassAccuracyChecks { get; set; }
    public bool HasFreeAOE { get; set; }

    // Effect Modifiers
    public int DamageModifier { get; set; }
    public int ConditionModifier { get; set; }
    public bool HasFreeConditions { get; set; }

    // Action Modifiers
    public int ExtraQuickActions { get; set; }
    public int QuickActionConversionCost { get; set; }

    // Point Modifiers
    public double MainPoolMultiplier { get; set; } = 1.0;
    public double UtilityPoolMultiplier { get; set; } = 1.0;
}

/// <summary>
/// Contains point calculations specific to archetype selections
/// </summary>
public class ArchetypePointsDto
{
    public int SpecialAttackBasePoints { get; set; }
    public int SpecialAttackLimit { get; set; }
    public double LimitPointMultiplier { get; set; }
    public bool CanTakeLimits { get; set; }
    public int SharedUses { get; set; }
}

/// <summary>
/// Contains validation information for archetype selections
/// </summary>
public class ArchetypeValidationDto
{
    public bool IsValid { get; set; }
    public ICollection<string> Errors { get; set; } = new List<string>();
    public ICollection<string> Warnings { get; set; } = new List<string>();
    public ICollection<string> Incompatibilities { get; set; } = new List<string>();
}
--------------------------------------------------

File: server\Domain\Dtos\Attributes\CharacterBasicDto.cs
Content:
using System.ComponentModel.DataAnnotations;
using VitalityBuilder.Domain.Constants;

namespace VitalityBuilder.Domain.Dtos.Character;

/// <summary>
/// Basic data transfer object for character creation and updates
/// </summary>
public class CharacterBasicDto
{
    [Required]
    [StringLength(100, MinimumLength = 1)]
    public string Name { get; set; } = string.Empty;

    [Range(GameRuleConstants.MinimumTier, GameRuleConstants.MaximumTier)]
    public int Tier { get; set; }

    // Combat Attributes
    [Range(0, GameRuleConstants.MaximumTier)]
    public int Focus { get; set; }

    [Range(0, GameRuleConstants.MaximumTier)]
    public int Power { get; set; }

    [Range(0, GameRuleConstants.MaximumTier)]
    public int Mobility { get; set; }

    [Range(0, GameRuleConstants.MaximumTier)]
    public int Endurance { get; set; }

    // Utility Attributes
    [Range(0, GameRuleConstants.MaximumTier)]
    public int Awareness { get; set; }

    [Range(0, GameRuleConstants.MaximumTier)]
    public int Communication { get; set; }

    [Range(0, GameRuleConstants.MaximumTier)]
    public int Intelligence { get; set; }

    // Archetype Selections
    [Required]
    public string MovementArchetype { get; set; } = string.Empty;

    [Required]
    public string AttackArchetype { get; set; } = string.Empty;

    [Required]
    public string EffectArchetype { get; set; } = string.Empty;

    [Required]
    public string UniqueAbilityArchetype { get; set; } = string.Empty;

    [Required]
    public string SpecialAttackArchetype { get; set; } = string.Empty;

    [Required]
    public string UtilityArchetype { get; set; } = string.Empty;
}
--------------------------------------------------

File: server\Domain\Dtos\Attributes\CharacterResponseDto.cs
Content:
namespace VitalityBuilder.Domain.Dtos.Character;

/// <summary>
/// Comprehensive character data transfer object for API responses
/// </summary>
public class CharacterResponseDto
{
    // Basic Information
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public int Tier { get; set; }
    public int HealthPool { get; set; }
    public int EffortRemaining { get; set; }

    // Point Pools
    public PointPoolsDto PointPools { get; set; } = new();

    // Attributes
    public CombatAttributesDto CombatAttributes { get; set; } = new();
    public UtilityAttributesDto UtilityAttributes { get; set; } = new();

    // Archetypes
    public CharacterArchetypesDto Archetypes { get; set; } = new();

    // Derived Combat Stats
    public CombatStatsDto CombatStats { get; set; } = new();

    // Collections
    public ICollection<SpecialAttackDto> SpecialAttacks { get; set; } = new List<SpecialAttackDto>();
    public ICollection<CharacterFeatureDto> Features { get; set; } = new List<CharacterFeatureDto>();
    public ICollection<CharacterExpertiseDto> Expertise { get; set; } = new List<CharacterExpertiseDto>();

    // Validation Information
    public ICollection<string> Warnings { get; set; } = new List<string>();
}

public class PointPoolsDto
{
    public int MainPool { get; set; }
    public int MainPoolSpent { get; set; }
    public int MainPoolRemaining => MainPool - MainPoolSpent;

    public int UtilityPoints { get; set; }
    public int UtilityPointsSpent { get; set; }
    public int UtilityPointsRemaining => UtilityPoints - UtilityPointsSpent;

    public int CombatAttributePoints { get; set; }
    public int CombatAttributePointsSpent { get; set; }
    public int CombatAttributePointsRemaining => CombatAttributePoints - CombatAttributePointsSpent;

    public int UtilityAttributePoints { get; set; }
    public int UtilityAttributePointsSpent { get; set; }
    public int UtilityAttributePointsRemaining => UtilityAttributePoints - UtilityAttributePointsSpent;
}

public class CombatStatsDto
{
    // Core Combat Values
    public int Avoidance { get; set; }
    public int Durability { get; set; }
    public int MovementSpeed { get; set; }
    public int Initiative { get; set; }

    // Resistances
    public int ResolveResistance { get; set; }
    public int StabilityResistance { get; set; }
    public int VitalityResistance { get; set; }

    // Combat Bonuses
    public int BaseAccuracyBonus { get; set; }
    public int BaseDamageBonus { get; set; }
    public int BaseConditionBonus { get; set; }

    // Archetype Modifications
    public int ArchetypeAccuracyModifier { get; set; }
    public int ArchetypeDamageModifier { get; set; }
    public int ArchetypeConditionModifier { get; set; }

    // Final Values (Including All Modifiers)
    public int FinalAccuracy => BaseAccuracyBonus + ArchetypeAccuracyModifier;
    public int FinalDamage => BaseDamageBonus + ArchetypeDamageModifier;
    public int FinalCondition => BaseConditionBonus + ArchetypeConditionModifier;
}

public class SpecialAttackDto
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string AttackType { get; set; } = string.Empty;
    public string EffectType { get; set; } = string.Empty;
    public int PointCost { get; set; }
    public ICollection<string> Limits { get; set; } = new List<string>();
    public ICollection<string> Upgrades { get; set; } = new List<string>();
}

public class CharacterFeatureDto
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public int PointCost { get; set; }
    public string Category { get; set; } = string.Empty;
}

public class CharacterExpertiseDto
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Category { get; set; } = string.Empty;
    public int PointCost { get; set; }
    public int BonusValue { get; set; }
}
--------------------------------------------------

File: server\Domain\Dtos\Character\CombatAttributesDto.cs
Content:
using System.ComponentModel.DataAnnotations;
using VitalityBuilder.Domain.Constants;

namespace VitalityBuilder.Domain.Dtos.Attributes;

/// <summary>
/// Data transfer object for combat-related attributes
/// </summary>
public class CombatAttributesDto
{
    [Range(0, GameRuleConstants.MaximumTier)]
    public int Focus { get; set; }

    [Range(0, GameRuleConstants.MaximumTier)]
    public int Power { get; set; }

    [Range(0, GameRuleConstants.MaximumTier)]
    public int Mobility { get; set; }

    [Range(0, GameRuleConstants.MaximumTier)]
    public int Endurance { get; set; }

    // Calculated Values
    public int TotalPoints => Focus + Power + Mobility + Endurance;

    public int AvailablePoints { get; set; }
    public int RemainingPoints => AvailablePoints - TotalPoints;

    // Combat Values (Calculated with Tier)
    public CombatValuesDto Values { get; set; } = new();

    public bool ValidateAgainstTier(int tier)
    {
        // Individual attributes cannot exceed tier
        if (Focus > tier || Power > tier || Mobility > tier || Endurance > tier)
        {
            return false;
        }

        // Total points cannot exceed tier × 2
        if (TotalPoints > tier * 2)
        {
            return false;
        }

        return true;
    }
}

/// <summary>
/// Calculated combat values based on attributes and tier
/// </summary>
public class CombatValuesDto
{
    // Core Defense Values
    public int Avoidance { get; set; }
    public int Durability { get; set; }

    // Resistance Values
    public int ResolveResistance { get; set; }
    public int StabilityResistance { get; set; }
    public int VitalityResistance { get; set; }

    // Combat Bonuses
    public int DamageBonus { get; set; }
    public int MovementSpeed { get; set; }

    // Point Status
    public bool HasSufficientPoints { get; set; }
    public ICollection<string> ValidationMessages { get; set; } = new List<string>();
}
--------------------------------------------------

File: server\Domain\Dtos\Character\UtilityAttributesDto.cs
Content:
using System.ComponentModel.DataAnnotations;
using VitalityBuilder.Domain.Constants;

namespace VitalityBuilder.Domain.Dtos.Attributes;

/// <summary>
/// Data transfer object for utility-related attributes
/// </summary>
public class UtilityAttributesDto
{
    [Range(0, GameRuleConstants.MaximumTier)]
    public int Awareness { get; set; }

    [Range(0, GameRuleConstants.MaximumTier)]
    public int Communication { get; set; }

    [Range(0, GameRuleConstants.MaximumTier)]
    public int Intelligence { get; set; }

    // Calculated Values
    public int TotalPoints => Awareness + Communication + Intelligence;

    public int AvailablePoints { get; set; }
    public int RemainingPoints => AvailablePoints - TotalPoints;

    // Utility Values (Calculated with Tier)
    public UtilityValuesDto Values { get; set; } = new();

    public bool ValidateAgainstTier(int tier)
    {
        // Individual attributes cannot exceed tier
        if (Awareness > tier || Communication > tier || Intelligence > tier)
        {
            return false;
        }

        // Total points cannot exceed tier
        if (TotalPoints > tier)
        {
            return false;
        }

        return true;
    }
}

/// <summary>
/// Calculated utility values based on attributes and tier
/// </summary>
public class UtilityValuesDto
{
    // Core Ability Values
    public int InitiativeBonus { get; set; }
    public int DynamicEntryAllies { get; set; }
    public int DynamicEntrySpaces { get; set; }

    // Skill Check Information
    public ICollection<SkillBonusDto> SkillBonuses { get; set; } = new List<SkillBonusDto>();

    // Point Status
    public bool HasSufficientPoints { get; set; }
    public ICollection<string> ValidationMessages { get; set; } = new List<string>();
}

/// <summary>
/// Represents skill check bonuses for specific skills
/// </summary>
public class SkillBonusDto
{
    public string SkillName { get; set; } = string.Empty;
    public string AttributeName { get; set; } = string.Empty;
    public int AttributeBonus { get; set; }
    public int ExpertiseBonus { get; set; }
    public int TotalBonus => AttributeBonus + ExpertiseBonus;
}
--------------------------------------------------
