=== Directory Tree ===
src/
  appsettings.Development.json
  appsettings.json
  controllers/
    CharactersController.cs
  data/
    ICharacterRepository.cs
  Data.cs
  Infrastructure/
    AppDbContext.cs
    ArchetypeDbContext.cs
    JsonValueConverter.cs
  models/
    Archetypes/
      AttackTypeArchetype.cs
      CharacterArchetypes.cs
      EffectTypeArchetype.cs
      Enums.cs
      MovementArchetype.cs
      SpecialAttackArchetype.cs
      UniqueAbilityArchetype.cs
      UtilityArchetype.cs
    DTOs/
      CharacterArchetypesDTOs.cs
      CharacterDTOs.cs
    Entities/
      Character.cs
      CharacterArchetypes.cs
      CombatAttributes.cs
      Expertise.cs
      SpecialAttack.cs
      UniquePower.cs
      UtilityAttributes.cs
  Program.cs
  Properties/
    launchSettings.json
  services/
    CharacterArchetypesService.Calculations.cs
    CharacterArchetypesService.cs
    CharacterArchetypesService.Helpers.cs
    CharacterArchetypesService.Mapping.cs
    ICharacterArchetypesServices.cs

=== File Contents ===

File: appsettings.Development.json
Content:
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}

--------------------------------------------------

File: appsettings.json
Content:
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost;Database=VitalityBuilder;Trusted_Connection=True;TrustServerCertificate=True;MultipleActiveResultSets=true"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}
--------------------------------------------------

File: Data.cs
Content:

--------------------------------------------------

File: Program.cs
Content:
using Microsoft.EntityFrameworkCore;
using Microsoft.OpenApi.Models;
using System.Text.Json.Serialization;
using VitalityBuilder.Api;

var builder = WebApplication.CreateBuilder(args);

// Configure JSON options
builder.Services.AddControllers()
    .AddJsonOptions(options =>
    {
        options.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles;
        options.JsonSerializerOptions.DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull;
    });

// Configure logging
builder.Services.AddLogging(logging =>
{
    logging.AddConsole();
    logging.AddDebug();
});

// Add database context
builder.Services.AddDbContext<VitalityBuilderContext>(options => 
{
    var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
    options.UseSqlServer(connectionString);
    // Add logging for development
    if (builder.Environment.IsDevelopment())
    {
        options.EnableSensitiveDataLogging();
        options.EnableDetailedErrors();
    }
});

// Add Swagger
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(options =>
{
    options.SwaggerDoc("v1", new OpenApiInfo
    {
        Version = "v1",
        Title = "Vitality System Character Builder API",
        Description = "An ASP.NET Core Web API for managing Vitality System character creation"
    });
});

var app = builder.Build();

// Configure middleware
app.UseSwagger();
app.UseSwaggerUI(options =>
{
    options.SwaggerEndpoint("/swagger/v1/swagger.json", "v1");
    options.RoutePrefix = string.Empty;
});

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

// Ensure database exists
using (var scope = app.Services.CreateScope())
{
    var context = scope.ServiceProvider.GetRequiredService<VitalityBuilderContext>();
    context.Database.EnsureCreated();
}

app.Run();
--------------------------------------------------

File: controllers\CharactersController.cs
Content:
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using VitalityBuilder.Api.Models;

namespace VitalityBuilder.Api.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class CharactersController : ControllerBase
    {
        private readonly VitalityBuilderContext _context;
        private readonly ILogger<CharactersController> _logger;

        public CharactersController(VitalityBuilderContext context, ILogger<CharactersController> logger)
        {
            _context = context;
            _logger = logger;
        }

        [HttpPost]
        public async Task<ActionResult<Character>> CreateCharacter(CreateCharacterDto dto)
        {
            _logger.LogInformation("Received character creation request for {CharacterName}", dto.Name);

            if (!ValidateCharacterDto(dto))
            {
                _logger.LogWarning("Character validation failed for {CharacterName}", dto.Name);
                return BadRequest("Invalid character data");
            }

            try 
            {
                var character = new Character
                {
                    Name = dto.Name,
                    Tier = dto.Tier,
                    MainPointPool = dto.MainPointPool,
                    SpecialAttacksPointPool = dto.SpecialAttacksPointPool,
                    UtilityPointPool = dto.UtilityPointPool,
                    CombatAttributes = new CombatAttributes
                    {
                        Focus = dto.CombatAttributes.Focus,
                        Power = dto.CombatAttributes.Power,
                        Mobility = dto.CombatAttributes.Mobility,
                        Endurance = dto.CombatAttributes.Endurance
                    },
                    UtilityAttributes = new UtilityAttributes
                    {
                        Awareness = dto.UtilityAttributes.Awareness,
                        Communication = dto.UtilityAttributes.Communication,
                        Intelligence = dto.UtilityAttributes.Intelligence
                    }
                };

                _context.Characters.Add(character);
                await _context.SaveChangesAsync();

                _logger.LogInformation("Successfully created character {CharacterName} with ID {CharacterId}", 
                    character.Name, character.Id);

                return CreatedAtAction(
                    nameof(GetCharacter),
                    new { id = character.Id },
                    character);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating character {CharacterName}", dto.Name);
                return StatusCode(500, "An error occurred while creating the character");
            }
        }


        [HttpGet("{id}")]
        public async Task<ActionResult<Character>> GetCharacter(int id)
        {
            var character = await _context.Characters
                .Include(c => c.CombatAttributes)
                .Include(c => c.UtilityAttributes)
                .Include(c => c.Expertise)
                .Include(c => c.SpecialAttacks)
                .Include(c => c.UniquePowers)
                .FirstOrDefaultAsync(c => c.Id == id);

            if (character == null)
            {
                return NotFound();
            }

            return character;
        }


        private static bool ValidateCharacterDto(CreateCharacterDto dto)
        {
            // Validate tier range
            if (dto.Tier < 1 || dto.Tier > 10)
                return false;

            // Combat attributes total must not exceed tier × 2
            int combatTotal = dto.CombatAttributes.Focus + dto.CombatAttributes.Power + 
                            dto.CombatAttributes.Mobility + dto.CombatAttributes.Endurance;
            if (combatTotal > dto.Tier * 2 ||
                dto.CombatAttributes.Focus > dto.Tier ||
                dto.CombatAttributes.Power > dto.Tier ||
                dto.CombatAttributes.Mobility > dto.Tier ||
                dto.CombatAttributes.Endurance > dto.Tier)
                return false;

            // Utility attributes total must not exceed tier
            int utilityTotal = dto.UtilityAttributes.Awareness + dto.UtilityAttributes.Communication + 
                             dto.UtilityAttributes.Intelligence;
            if (utilityTotal > dto.Tier ||
                dto.UtilityAttributes.Awareness > dto.Tier ||
                dto.UtilityAttributes.Communication > dto.Tier ||
                dto.UtilityAttributes.Intelligence > dto.Tier)
                return false;

            // Main pool calculation: (Tier - 2) × 15
            int expectedMainPool = Math.Max(0, (dto.Tier - 2) * 15);
            if (dto.MainPointPool > expectedMainPool)
                return false;

            // Special attacks count validation
            if (dto.SpecialAttacks.Count > dto.Tier)
                return false;

            // Expertise points validation: 5 × (Tier - 1)
            int maxExpertisePoints = 5 * (dto.Tier - 1);
            int usedExpertisePoints = dto.Expertise.Sum(e => e.Cost);
            if (usedExpertisePoints > maxExpertisePoints)
                return false;

            return true;
        }
    }
}
--------------------------------------------------

File: data\ICharacterRepository.cs
Content:
using VitalityBuilder.Api.Models; 
public interface ICharacterRepository
{
    Task<Character> CreateCharacterAsync(Character character);
    Task<List<Character>> GetAllCharactersAsync();
    Task<Character?> GetCharacterByIdAsync(int id);
}
--------------------------------------------------

File: Infrastructure\AppDbContext.cs
Content:
using Microsoft.EntityFrameworkCore;
using VitalityBuilder.Api.Infrastructure;
using VitalityBuilder.Api.Models;
using VitalityBuilder.Api.Models.Archetypes;

namespace VitalityBuilder.Api.Infrastructure;

public class VitalityBuilderContext(DbContextOptions<VitalityBuilderContext> options) : DbContext(options)
{
    public DbSet<Models.Archetypes.CharacterArchetypes> CharacterArchetypes => Set<Models.Archetypes.CharacterArchetypes>();
    public DbSet<Character> Characters => Set<Character>();
    public DbSet<CombatAttributes> CombatAttributes => Set<CombatAttributes>();
    public DbSet<UtilityAttributes> UtilityAttributes => Set<UtilityAttributes>();
    public DbSet<Expertise> Expertise => Set<Expertise>();
    public DbSet<SpecialAttack> SpecialAttacks => Set<SpecialAttack>();
    public DbSet<UniquePower> UniquePowers => Set<UniquePower>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Configure Character relationships
        modelBuilder.Entity<Character>(entity =>
        {
            entity.HasKey(e => e.Id);
            
            entity.HasOne(e => e.CombatAttributes)
                .WithOne(e => e.Character)
                .HasForeignKey<CombatAttributes>(e => e.CharacterId)
                .IsRequired()
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasOne(e => e.UtilityAttributes)
                .WithOne(e => e.Character)
                .HasForeignKey<UtilityAttributes>(e => e.CharacterId)
                .IsRequired()
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasMany(e => e.Expertise)
                .WithOne(e => e.Character)
                .HasForeignKey(e => e.CharacterId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasMany(e => e.SpecialAttacks)
                .WithOne(e => e.Character)
                .HasForeignKey(e => e.CharacterId)
                .OnDelete(DeleteBehavior.Cascade);

            entity.HasMany(e => e.UniquePowers)
                .WithOne(e => e.Character)
                .HasForeignKey(e => e.CharacterId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // Configure MovementArchetype
        modelBuilder.Entity<Models.Archetypes.MovementArchetype>(entity =>
        {
            entity.Property(e => e.SpeedBonusByTier)
                .HasConversion(new JsonValueConverter<Dictionary<int, int>>())
                .Metadata.SetValueComparer(new JsonValueComparer<Dictionary<int, int>>());
        });

        // Configure SpecialAttack
        modelBuilder.Entity<SpecialAttack>(entity =>
        {
            entity.Property(e => e.Limits)
                .HasConversion(new JsonValueConverter<List<string>>())
                .Metadata.SetValueComparer(new JsonValueComparer<List<string>>());

            entity.Property(e => e.Upgrades)
                .HasConversion(new JsonValueConverter<List<string>>())
                .Metadata.SetValueComparer(new JsonValueComparer<List<string>>());
        });

        // Configure UniqueAbilityArchetype
        modelBuilder.Entity<Models.Archetypes.UniqueAbilityArchetype>(entity =>
        {
            entity.Property(e => e.StatBonuses)
                .HasConversion(new JsonValueConverter<Dictionary<string, int>>())
                .Metadata.SetValueComparer(new JsonValueComparer<Dictionary<string, int>>());
        });

        // Configure UtilityArchetype
        modelBuilder.Entity<Models.Archetypes.UtilityArchetype>(entity =>
        {
            entity.Property(e => e.Restrictions)
                .HasConversion(new JsonValueConverter<List<string>>())
                .Metadata.SetValueComparer(new JsonValueComparer<List<string>>());
        });
    }
}
--------------------------------------------------

File: Infrastructure\ArchetypeDbContext.cs
Content:
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using System.Text.Json;
using VitalityBuilder.Api.Models;

namespace VitalityBuilder.Api.Infrastructure
{
    /// <summary>
    /// Database context for handling character archetype-related data and relationships.
    /// This context manages the persistence of character archetypes and their associated rule configurations.
    /// </summary>
    public class ArchetypeDbContext : DbContext
    {
        public ArchetypeDbContext(DbContextOptions<ArchetypeDbContext> options) : base(options) { }

        /// <summary>
        /// Database set for character archetypes and their associated components
        /// </summary>
        public DbSet<CharacterArchetypes> CharacterArchetypes => Set<CharacterArchetypes>();

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            ConfigureCharacterArchetypes(modelBuilder);
            ConfigureMovementArchetype(modelBuilder);
            ConfigureAttackTypeArchetype(modelBuilder);
            ConfigureEffectTypeArchetype(modelBuilder);
            ConfigureUniqueAbilityArchetype(modelBuilder);
            ConfigureSpecialAttackArchetype(modelBuilder);
            ConfigureUtilityArchetype(modelBuilder);
        }

        private void ConfigureCharacterArchetypes(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<CharacterArchetypes>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Id).ValueGeneratedOnAdd();
                
                // Configure one-to-one relationship with Character
                entity.HasOne(e => e.Character)
                    .WithOne()
                    .HasForeignKey<CharacterArchetypes>(e => e.CharacterId)
                    .OnDelete(DeleteBehavior.Cascade);

                // Configure required navigation properties
                entity.Navigation(e => e.MovementArchetype).IsRequired();
                entity.Navigation(e => e.AttackTypeArchetype).IsRequired();
                entity.Navigation(e => e.EffectTypeArchetype).IsRequired();
                entity.Navigation(e => e.UniqueAbilityArchetype).IsRequired();
                entity.Navigation(e => e.SpecialAttackArchetype).IsRequired();
                entity.Navigation(e => e.UtilityArchetype).IsRequired();

                // Configure table name
                entity.ToTable("CharacterArchetypes");
            });
        }

        private void ConfigureMovementArchetype(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<MovementArchetype>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Id).ValueGeneratedOnAdd();
                
                entity.Property(e => e.SpeedBonusByTier)
                    .HasConversion(
                        v => JsonSerializer.Serialize(v, JsonSerializerOptions.Default),
                        v => JsonSerializer.Deserialize<Dictionary<int, int>>(v, JsonSerializerOptions.Default) 
                             ?? new Dictionary<int, int>(),
                        new ValueComparer<Dictionary<int, int>>(
                            (c1, c2) => c1!.SequenceEqual(c2!),
                            c => c.Aggregate(0, (a, v) => HashCode.Combine(a, v.GetHashCode())),
                            c => new Dictionary<int, int>(c)
                        )
                    );

                entity.Property(e => e.Type)
                    .HasConversion<string>();

                entity.ToTable("MovementArchetypes");
            });
        }

        private void ConfigureAttackTypeArchetype(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<AttackTypeArchetype>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Id).ValueGeneratedOnAdd();
                
                entity.Property(e => e.Category)
                    .HasConversion<string>();

                entity.ToTable("AttackTypeArchetypes");
            });
        }

        private void ConfigureEffectTypeArchetype(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<EffectTypeArchetype>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Id).ValueGeneratedOnAdd();
                
                entity.Property(e => e.Category)
                    .HasConversion<string>();

                entity.ToTable("EffectTypeArchetypes");
            });
        }

        private void ConfigureUniqueAbilityArchetype(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<UniqueAbilityArchetype>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Id).ValueGeneratedOnAdd();
                
                entity.Property(e => e.StatBonuses)
                    .HasConversion(
                        v => JsonSerializer.Serialize(v, JsonSerializerOptions.Default),
                        v => JsonSerializer.Deserialize<Dictionary<string, int>>(v, JsonSerializerOptions.Default) 
                             ?? new Dictionary<string, int>(),
                        new ValueComparer<Dictionary<string, int>>(
                            (c1, c2) => c1!.SequenceEqual(c2!),
                            c => c.Aggregate(0, (a, v) => HashCode.Combine(a, v.GetHashCode())),
                            c => new Dictionary<string, int>(c)
                        )
                    );

                entity.Property(e => e.Category)
                    .HasConversion<string>();

                entity.ToTable("UniqueAbilityArchetypes");
            });
        }

        private void ConfigureSpecialAttackArchetype(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<SpecialAttackArchetype>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Id).ValueGeneratedOnAdd();
                
                entity.Property(e => e.RequiredLimits)
                    .HasConversion(
                        v => JsonSerializer.Serialize(v, JsonSerializerOptions.Default),
                        v => JsonSerializer.Deserialize<List<string>>(v, JsonSerializerOptions.Default) 
                             ?? new List<string>(),
                        new ValueComparer<List<string>>(
                            (c1, c2) => c1!.SequenceEqual(c2!),
                            c => c.Aggregate(0, (a, v) => HashCode.Combine(a, v.GetHashCode())),
                            c => new List<string>(c)
                        )
                    );

                entity.Property(e => e.Category)
                    .HasConversion<string>();

                entity.ToTable("SpecialAttackArchetypes");
            });
        }

        private void ConfigureUtilityArchetype(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<UtilityArchetype>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Id).ValueGeneratedOnAdd();
                
                entity.Property(e => e.Restrictions)
                    .HasConversion(
                        v => JsonSerializer.Serialize(v, JsonSerializerOptions.Default),
                        v => JsonSerializer.Deserialize<List<string>>(v, JsonSerializerOptions.Default) 
                             ?? new List<string>(),
                        new ValueComparer<List<string>>(
                            (c1, c2) => c1!.SequenceEqual(c2!),
                            c => c.Aggregate(0, (a, v) => HashCode.Combine(a, v.GetHashCode())),
                            c => new List<string>(c)
                        )
                    );

                entity.Property(e => e.Category)
                    .HasConversion<string>();

                entity.ToTable("UtilityArchetypes");
            });
        }
    }
}
--------------------------------------------------

File: Infrastructure\JsonValueConverter.cs
Content:
using System.Text.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.ChangeTracking;

namespace VitalityBuilder.Api.Infrastructure;

/// <summary>
/// Generic JSON value converter for Entity Framework Core
/// </summary>
public class JsonValueConverter<T> : ValueConverter<T, string> where T : class
{
    public JsonValueConverter() : base(
        // Serialize to JSON string
        v => JsonSerializer.Serialize(v, JsonSerializerOptions.Default),
        // Deserialize from JSON string with null handling
        v => v == null ? null! : JsonSerializer.Deserialize<T>(v, JsonSerializerOptions.Default)!
    )
    {
    }
}

/// <summary>
/// Generic JSON comparer for Entity Framework Core
/// </summary>
public class JsonValueComparer<T> : ValueComparer<T> where T : class
{
    private static bool EqualsJson(T? left, T? right)
    {
        if (left == null && right == null)
            return true;
        if (left == null || right == null)
            return false;
        return JsonSerializer.Serialize(left) == JsonSerializer.Serialize(right);
    }

    private static int GetHashCodeJson(T value)
    {
        if (value == null)
            return 0;
        return JsonSerializer.Serialize(value).GetHashCode();
    }

    private static T GetSnapshotJson(T value)
    {
        if (value == null)
            return null!;
        var json = JsonSerializer.Serialize(value);
        return JsonSerializer.Deserialize<T>(json)!;
    }

    public JsonValueComparer() : base(
        (l, r) => EqualsJson(l, r),
        v => GetHashCodeJson(v),
        v => GetSnapshotJson(v))
    {
    }
}
--------------------------------------------------

File: Properties\launchSettings.json
Content:
﻿{
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "http://localhost:5034",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
--------------------------------------------------

File: services\CharacterArchetypesService.Calculations.cs
Content:
using VitalityBuilder.Api.Models;
using VitalityBuilder.Api.Models.Archetypes;

namespace VitalityBuilder.Api.Services;

public partial class CharacterArchetypesService
{
    public int CalculateMovementSpeed(Models.Archetypes.MovementArchetype archetype, int tier, int mobility)
    {
        // Base movement is the higher of (6) or (mobility + tier)
        var baseSpeed = Math.Max(6, mobility + tier);
        
        // Apply archetype-specific modifiers
        switch (archetype.Type)
        {
            case Models.Archetypes.MovementArchetypeType.Swift:
                // Swift characters get bonus speed based on tier level
                baseSpeed += (tier + 1) / 2;
                break;
            case Models.Archetypes.MovementArchetypeType.Flight:
            case Models.Archetypes.MovementArchetypeType.Teleportation:
            case Models.Archetypes.MovementArchetypeType.Portal:
                baseSpeed = AdjustSpecialMovementSpeedForType(archetype.Type, baseSpeed);
                break;
        }

        // Apply any tier-specific bonuses configured for this archetype
        if (archetype.SpeedBonusByTier.TryGetValue(tier, out int bonus))
        {
            baseSpeed += bonus;
        }

        // Apply movement multiplier (e.g., for effects like swimming)
        return (int)(baseSpeed * archetype.MovementMultiplier);
    }

    private int AdjustSpecialMovementSpeedForType(Models.Archetypes.MovementArchetypeType type, int baseSpeed)
    {
        // Implement the logic for adjusting special movement speed here
        // For now, let's just return the baseSpeed as a placeholder
        return baseSpeed;
    }

    public int CalculateSpecialAttackPoints(Models.Archetypes.SpecialAttackArchetype archetype, int tier)
    {
        return archetype.Category switch
        {
            // Normal gets points based on limits
            Models.Archetypes.SpecialAttackCategory.Normal => CalculateNormalArchetypePoints(tier),
            
            // Paragon gets 10 × Tier points but can't take limits
            Models.Archetypes.SpecialAttackCategory.Paragon => 10 * tier,
            
            // One Trick gets 20 × Tier points for a single powerful attack
            Models.Archetypes.SpecialAttackCategory.OneTrick => 20 * tier,
            
            // Dual-Natured gets 15 × Tier points for two balanced attacks
            Models.Archetypes.SpecialAttackCategory.DualNatured => 15 * tier,
            
            // Basic gets 10 × Tier points for enhancing base attacks
            Models.Archetypes.SpecialAttackCategory.Basic => 10 * tier,
            
            // Specialist gains enhanced points from required limits
            Models.Archetypes.SpecialAttackCategory.Specialist => CalculateSpecialistPoints(tier, archetype.RequiredLimits),
            
            _ => 0
        };
    }

    public int CalculateUtilityPoints(Models.Archetypes.UtilityArchetype archetype, int tier)
    {
        return archetype.Category switch
        {
            // Standard points: 5 × (Tier - 1)
            Models.Archetypes.UtilityCategory.Practical => 5 * (tier - 1),
            
            // Specialized gets double tier bonus but restricted options
            Models.Archetypes.UtilityCategory.Specialized => 5 * (tier - 2),
            
            // Jack of All Trades gets fewer points but applies tier to all checks
            Models.Archetypes.UtilityCategory.JackOfAllTrades => 5 * (tier - 2),
            
            _ => 0
        };
    }

    public Dictionary<string, int> CalculateArchetypeBonuses(Models.Archetypes.CharacterArchetypes archetypes, int tier)
    {
        var bonuses = new Dictionary<string, int>();

        // Add movement archetype bonuses
        if (archetypes.MovementArchetype.Type == Models.Archetypes.MovementArchetypeType.Swift)
        {
            bonuses["MovementSpeed"] = (tier + 1) / 2;
        }

        // Add attack type bonuses/penalties
        if (archetypes.AttackTypeArchetype.Category == Models.Archetypes.AttackTypeArchetypeCategory.AOESpecialist)
        {
            bonuses["AOEAccuracy"] = -tier;
        }
        else if (archetypes.AttackTypeArchetype.Category == Models.Archetypes.AttackTypeArchetypeCategory.DirectSpecialist)
        {
            bonuses["DirectEffect"] = -tier;
        }

        // Add effect type bonuses/penalties
        if (archetypes.EffectTypeArchetype.Category == Models.Archetypes.EffectTypeCategory.HybridSpecialist)
        {
            bonuses["DamageRoll"] = -tier;
            bonuses["ConditionRoll"] = -tier;
        }
        else if (archetypes.EffectTypeArchetype.Category == Models.Archetypes.EffectTypeCategory.CrowdControl)
        {
            bonuses["DamageRoll"] = -tier;
        }

        // Add Cut Above archetype bonuses
        if (archetypes.UniqueAbilityArchetype.Category == Models.Archetypes.UniqueAbilityCategory.CutAbove)
        {
            var bonus = tier switch
            {
                <= 4 => 1,
                <= 7 => 2,
                _ => 3
            };
            
            bonuses["AllStats"] = bonus;
        }

        return bonuses;
    }
}
--------------------------------------------------

File: services\CharacterArchetypesService.cs
Content:
using Microsoft.Extensions.Logging;
using VitalityBuilder.Api.Infrastructure;
using VitalityBuilder.Api.Models;
using VitalityBuilder.Api.Models.Archetypes;
using VitalityBuilder.Api.Models.DTOs;

namespace VitalityBuilder.Api.Services;

/// <summary>
/// Service implementing character archetype management and calculations
/// </summary>
public partial class CharacterArchetypesService : ICharacterArchetypesService
{
    private readonly ArchetypeDbContext _context;
    private readonly ILogger<CharacterArchetypesService> _logger;

    public CharacterArchetypesService(ArchetypeDbContext context, ILogger<CharacterArchetypesService> logger)
    {
        _context = context;
        _logger = logger;
    }

    public async Task<Models.Archetypes.CharacterArchetypes> CreateArchetypesAsync(CharacterArchetypesDto dto, int characterId)
    {
        _logger.LogInformation("Creating archetypes for character {CharacterId}", characterId);

        try
        {
            var archetypes = new Models.Archetypes.CharacterArchetypes
            {
                CharacterId = characterId,
                MovementArchetype = MapMovementArchetype(dto.MovementArchetype),
                AttackTypeArchetype = MapAttackTypeArchetype(dto.AttackTypeArchetype),
                EffectTypeArchetype = MapEffectTypeArchetype(dto.EffectTypeArchetype),
                UniqueAbilityArchetype = MapUniqueAbilityArchetype(dto.UniqueAbilityArchetype),
                SpecialAttackArchetype = MapSpecialAttackArchetype(dto.SpecialAttackArchetype),
                UtilityArchetype = MapUtilityArchetype(dto.UtilityArchetype)
            };

            _context.Set<Models.Archetypes.CharacterArchetypes>().Add(archetypes);
            await _context.SaveChangesAsync();

            _logger.LogInformation("Successfully created archetypes for character {CharacterId}", characterId);
            return archetypes;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating archetypes for character {CharacterId}", characterId);
            throw;
        }
    }

}

--------------------------------------------------

File: services\CharacterArchetypesService.Helpers.cs
Content:
using VitalityBuilder.Api.Models.Archetypes;

namespace VitalityBuilder.Api.Services;

public partial class CharacterArchetypesService
{
    private static int CalculateNormalArchetypePoints(int tier) => tier * 10;

    private static int CalculateSpecialistPoints(int tier, List<string> requiredLimits)
    {
        float limitMultiplier = tier / 3.0f;
        int limitPoints = requiredLimits.Sum(GetLimitBaseValue);
        return (int)(limitPoints * limitMultiplier);
    }

    private static int GetLimitBaseValue(string limitName) => limitName switch
    {
        "Reload" => 20,
        "Stockpile" => 40,
        "Cooldown2" => 20,
        "Cooldown3" => 30,
        "Reserves3" => 10,
        "Reserves2" => 20,
        "Reserves1" => 40,
        "Finite5" => 10,
        "Finite3" => 20,
        "Finite2" => 30,
        "Finite1" => 50,
        "Charger" => 10,
        "Slowed" => 10,
        "Unreliable20" => 200,
        "Unreliable15" => 80,
        "Unreliable10" => 40,
        "Unreliable5" => 20,
        _ => 0
    };

    private static int AdjustSpecialMovementSpeed(MovementArchetypeType type, int baseSpeed) => type switch
    {
        MovementArchetypeType.Flight => baseSpeed,
        MovementArchetypeType.Teleportation => baseSpeed - 2, // Teleport has reduced range
        MovementArchetypeType.Portal => baseSpeed,
        _ => baseSpeed
    };
}

--------------------------------------------------

File: services\CharacterArchetypesService.Mapping.cs
Content:
using VitalityBuilder.Api.Models.Archetypes;
using VitalityBuilder.Api.Models.DTOs;

namespace VitalityBuilder.Api.Services;

public partial class CharacterArchetypesService 
{
    private static MovementArchetype MapMovementArchetype(MovementArchetypeDto dto) => 
        new()
        {
            Name = dto.Name,
            Type = (MovementArchetypeType)dto.Type,
            SpeedBonusByTier = dto.SpeedBonusByTier,
            IgnoresOpportunityAttacks = dto.IgnoresOpportunityAttacks,
            IgnoresDifficultTerrain = dto.IgnoresDifficultTerrain,
            IsImmuneToProne = dto.IsImmuneToProne,
            MovementMultiplier = dto.MovementMultiplier
        };

    private static AttackTypeArchetype MapAttackTypeArchetype(AttackTypeArchetypeDto dto) => 
        new()
        {
            Name = dto.Name,
            Category = (AttackTypeArchetypeCategory)dto.Category,
            AccuracyPenalty = dto.AccuracyPenalty,
            EffectPenalty = dto.EffectPenalty,
            BypassesAccuracyChecks = dto.BypassesAccuracyChecks,
            HasFreeAOE = dto.HasFreeAOE
        };

    private static EffectTypeArchetype MapEffectTypeArchetype(EffectTypeArchetypeDto dto) =>
        new()
        {
            Name = dto.Name,
            Category = (EffectTypeCategory)dto.Category,
            HasAccessToAdvancedConditions = dto.HasAccessToAdvancedConditions,
            DamagePenalty = dto.DamagePenalty,
            ConditionPenalty = dto.ConditionPenalty,
            RequiresHybridEffects = dto.RequiresHybridEffects
        };

    private static UniqueAbilityArchetype MapUniqueAbilityArchetype(UniqueAbilityArchetypeDto dto) =>
        new()
        {
            Name = dto.Name,
            Category = (UniqueAbilityCategory)dto.Category,
            ExtraQuickActions = dto.ExtraQuickActions,
            ExtraPointPool = dto.ExtraPointPool,
            StatBonuses = dto.StatBonuses
        };

    private static SpecialAttackArchetype MapSpecialAttackArchetype(SpecialAttackArchetypeDto dto) =>
        new()
        {
            Name = dto.Name,
            Category = (SpecialAttackCategory)dto.Category,
            BasePoints = dto.BasePoints,
            MaxSpecialAttacks = dto.MaxSpecialAttacks,
            LimitPointMultiplier = dto.LimitPointMultiplier,
            CanTakeLimits = dto.CanTakeLimits,
            RequiredLimits = dto.RequiredLimits
        };

    private static UtilityArchetype MapUtilityArchetype(UtilityArchetypeDto dto) =>
        new()
        {
            Name = dto.Name,
            Category = (UtilityCategory)dto.Category,
            BaseUtilityPool = dto.BaseUtilityPool,
            CanPurchaseExpertise = dto.CanPurchaseExpertise,
            TierBonusMultiplier = dto.TierBonusMultiplier,
            Restrictions = dto.Restrictions
        };
}

--------------------------------------------------

File: services\ICharacterArchetypesServices.cs
Content:
using VitalityBuilder.Api.Models;
using VitalityBuilder.Api.Models.Archetypes;
using VitalityBuilder.Api.Models.DTOs;

namespace VitalityBuilder.Api.Services;

/// <summary>
/// Interface defining core character archetype management operations
/// </summary>
public interface ICharacterArchetypesService
{
    Task<Models.Archetypes.CharacterArchetypes> CreateArchetypesAsync(CharacterArchetypesDto dto, int characterId);
    int CalculateMovementSpeed(Models.Archetypes.MovementArchetype archetype, int tier, int mobility);
    int CalculateSpecialAttackPoints(Models.Archetypes.SpecialAttackArchetype archetype, int tier);
    int CalculateUtilityPoints(Models.Archetypes.UtilityArchetype archetype, int tier);
    Dictionary<string, int> CalculateArchetypeBonuses(Models.Archetypes.CharacterArchetypes archetypes, int tier);
}

--------------------------------------------------

File: models\Archetypes\AttackTypeArchetype.cs
Content:
namespace VitalityBuilder.Api.Models.Archetypes;

public class AttackTypeArchetype
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public AttackTypeArchetypeCategory Category { get; set; }
    public int AccuracyPenalty { get; set; }
    public int EffectPenalty { get; set; }
    public bool BypassesAccuracyChecks { get; set; }
    public bool HasFreeAOE { get; set; }
    
    public int CharacterArchetypesId { get; set; }
    public CharacterArchetypes CharacterArchetypes { get; set; } = null!;
}
--------------------------------------------------

File: models\Archetypes\CharacterArchetypes.cs
Content:
using System.ComponentModel.DataAnnotations;

namespace VitalityBuilder.Api.Models.Archetypes;

public class CharacterArchetypes
{
    public int Id { get; set; }
    public MovementArchetype MovementArchetype { get; set; } = null!;
    public AttackTypeArchetype AttackTypeArchetype { get; set; } = null!;
    public EffectTypeArchetype EffectTypeArchetype { get; set; } = null!;
    public UniqueAbilityArchetype UniqueAbilityArchetype { get; set; } = null!;
    public SpecialAttackArchetype SpecialAttackArchetype { get; set; } = null!;
    public UtilityArchetype UtilityArchetype { get; set; } = null!;
    
    public int CharacterId { get; set; }
    public Character Character { get; set; } = null!;
}
--------------------------------------------------

File: models\Archetypes\EffectTypeArchetype.cs
Content:
namespace VitalityBuilder.Api.Models.Archetypes;

public class EffectTypeArchetype
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public EffectTypeCategory Category { get; set; }
    public bool HasAccessToAdvancedConditions { get; set; }
    public int DamagePenalty { get; set; }
    public int ConditionPenalty { get; set; }
    public bool RequiresHybridEffects { get; set; }
    
    public int CharacterArchetypesId { get; set; }
    public CharacterArchetypes CharacterArchetypes { get; set; } = null!;
}
--------------------------------------------------

File: models\Archetypes\Enums.cs
Content:
namespace VitalityBuilder.Api.Models.Archetypes;

public enum MovementArchetypeType
{
    Swift,
    Skirmisher,
    ParkourRunner,
    Behemoth,
    Bulwark,
    Vanguard,
    Mole,
    Flight,
    Teleportation,
    Portal,
    Swinging,
    SuperJump
}

public enum AttackTypeArchetypeCategory
{
    AOESpecialist,
    DirectSpecialist,
    SingleTarget
}

public enum EffectTypeCategory
{
    DamageSpecialist,
    HybridSpecialist,
    CrowdControl
}

public enum UniqueAbilityCategory
{
    VersatileMaster,
    Extraordinary,
    CutAbove
}

public enum SpecialAttackCategory
{
    Normal,
    Specialist,
    Paragon,
    OneTrick,
    Straightforward,
    SharedUses,
    DualNatured,
    Basic
}

public enum UtilityCategory
{
    Specialized,
    Practical,
    JackOfAllTrades
}
--------------------------------------------------

File: models\Archetypes\MovementArchetype.cs
Content:
using System.ComponentModel.DataAnnotations.Schema;

namespace VitalityBuilder.Api.Models.Archetypes;

public class MovementArchetype
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public MovementArchetypeType Type { get; set; }
    
    [Column(TypeName = "nvarchar(max)")]
    public Dictionary<int, int> SpeedBonusByTier { get; set; } = new();
    
    public bool IgnoresOpportunityAttacks { get; set; }
    public bool IgnoresDifficultTerrain { get; set; }
    public bool IsImmuneToProne { get; set; }
    public float MovementMultiplier { get; set; } = 1.0f;
    
    public int CharacterArchetypesId { get; set; }
    public CharacterArchetypes CharacterArchetypes { get; set; } = null!;
}
--------------------------------------------------

File: models\Archetypes\SpecialAttackArchetype.cs
Content:
namespace VitalityBuilder.Api.Models.Archetypes;

public class SpecialAttackArchetype
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public SpecialAttackCategory Category { get; set; }
    public int BasePoints { get; set; }
    public int MaxSpecialAttacks { get; set; }
    public float LimitPointMultiplier { get; set; }
    public bool CanTakeLimits { get; set; }
    public List<string> RequiredLimits { get; set; } = new();
    
    public int CharacterArchetypesId { get; set; }
    public CharacterArchetypes CharacterArchetypes { get; set; } = null!;
}

--------------------------------------------------

File: models\Archetypes\UniqueAbilityArchetype.cs
Content:
namespace VitalityBuilder.Api.Models.Archetypes;

public class UniqueAbilityArchetype
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public UniqueAbilityCategory Category { get; set; }
    public int ExtraQuickActions { get; set; }
    public int ExtraPointPool { get; set; }
    public Dictionary<string, int> StatBonuses { get; set; } = new();
    
    public int CharacterArchetypesId { get; set; }
    public CharacterArchetypes CharacterArchetypes { get; set; } = null!;
}
--------------------------------------------------

File: models\Archetypes\UtilityArchetype.cs
Content:
namespace VitalityBuilder.Api.Models.Archetypes;

public class UtilityArchetype
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public UtilityCategory Category { get; set; }
    public int BaseUtilityPool { get; set; }
    public bool CanPurchaseExpertise { get; set; }
    public float TierBonusMultiplier { get; set; }
    public List<string> Restrictions { get; set; } = new();
    
    public int CharacterArchetypesId { get; set; }
    public CharacterArchetypes CharacterArchetypes { get; set; } = null!;
}
--------------------------------------------------

File: models\DTOs\CharacterArchetypesDTOs.cs
Content:
// File: Models/DTOs/CharacterArchetypesDto.cs
namespace VitalityBuilder.Api.Models.DTOs;

/// <summary>
/// Data transfer object for creating or updating character archetypes
/// </summary>
public class CharacterArchetypesDto
{
    public MovementArchetypeDto MovementArchetype { get; set; } = null!;
    public AttackTypeArchetypeDto AttackTypeArchetype { get; set; } = null!;
    public EffectTypeArchetypeDto EffectTypeArchetype { get; set; } = null!;
    public UniqueAbilityArchetypeDto UniqueAbilityArchetype { get; set; } = null!;
    public SpecialAttackArchetypeDto SpecialAttackArchetype { get; set; } = null!;
    public UtilityArchetypeDto UtilityArchetype { get; set; } = null!;
}

public class MovementArchetypeDto
{
    public string Name { get; set; } = string.Empty;
    public MovementArchetypeType Type { get; set; }
    public Dictionary<int, int> SpeedBonusByTier { get; set; } = new();
    public bool IgnoresOpportunityAttacks { get; set; }
    public bool IgnoresDifficultTerrain { get; set; }
    public bool IsImmuneToProne { get; set; }
    public float MovementMultiplier { get; set; } = 1.0f;
}

public class AttackTypeArchetypeDto
{
    public string Name { get; set; } = string.Empty;
    public AttackTypeArchetypeCategory Category { get; set; }
    public int AccuracyPenalty { get; set; }
    public int EffectPenalty { get; set; }
    public bool BypassesAccuracyChecks { get; set; }
    public bool HasFreeAOE { get; set; }
}

public class EffectTypeArchetypeDto
{
    public string Name { get; set; } = string.Empty;
    public EffectTypeCategory Category { get; set; }
    public bool HasAccessToAdvancedConditions { get; set; }
    public int DamagePenalty { get; set; }
    public int ConditionPenalty { get; set; }
    public bool RequiresHybridEffects { get; set; }
}

public class UniqueAbilityArchetypeDto
{
    public string Name { get; set; } = string.Empty;
    public UniqueAbilityCategory Category { get; set; }
    public int ExtraQuickActions { get; set; }
    public int ExtraPointPool { get; set; }
    public Dictionary<string, int> StatBonuses { get; set; } = new();
}

public class SpecialAttackArchetypeDto
{
    public string Name { get; set; } = string.Empty;
    public SpecialAttackCategory Category { get; set; }
    public int BasePoints { get; set; }
    public int MaxSpecialAttacks { get; set; }
    public float LimitPointMultiplier { get; set; }
    public bool CanTakeLimits { get; set; }
    public List<string> RequiredLimits { get; set; } = new();
}

public class UtilityArchetypeDto
{
    public string Name { get; set; } = string.Empty;
    public UtilityCategory Category { get; set; }
    public int BaseUtilityPool { get; set; }
    public bool CanPurchaseExpertise { get; set; }
    public float TierBonusMultiplier { get; set; }
    public List<string> Restrictions { get; set; } = new();
}
--------------------------------------------------

File: models\DTOs\CharacterDTOs.cs
Content:
namespace VitalityBuilder.Api.Models
{
    public class CreateCharacterDto
    {
        public string Name { get; set; } = string.Empty;
        public int Tier { get; set; } = 1;
        public int MainPointPool { get; set; }
        public int SpecialAttacksPointPool { get; set; }
        public int UtilityPointPool { get; set; }
        public CombatAttributesDto CombatAttributes { get; set; } = new();
        public UtilityAttributesDto UtilityAttributes { get; set; } = new();
        public List<ExpertiseDto> Expertise { get; set; } = new();
        public List<SpecialAttackDto> SpecialAttacks { get; set; } = new();
        public List<UniquePowerDto> UniquePowers { get; set; } = new();
    }

    public class CombatAttributesDto
    {
        public int Focus { get; set; }
        public int Power { get; set; }
        public int Mobility { get; set; }
        public int Endurance { get; set; }
    }

    public class UtilityAttributesDto
    {
        public int Awareness { get; set; }
        public int Communication { get; set; }
        public int Intelligence { get; set; }
    }

    public class ExpertiseDto
    {
        public string Name { get; set; } = string.Empty;
        public string Category { get; set; } = string.Empty;
        public int Cost { get; set; }
        public string Description { get; set; } = string.Empty;
    }

    public class SpecialAttackDto
    {
        public string Name { get; set; } = string.Empty;
        public string AttackType { get; set; } = string.Empty;
        public string EffectType { get; set; } = string.Empty;
        public List<string> Limits { get; set; } = new();
        public List<string> Upgrades { get; set; } = new();
    }

    public class UniquePowerDto
    {
        public string Name { get; set; } = string.Empty;
        public string Category { get; set; } = string.Empty;
        public int Cost { get; set; }
        public string Description { get; set; } = string.Empty;
    }
}
--------------------------------------------------

File: models\Entities\Character.cs
Content:
using System.Text.Json.Serialization;

namespace VitalityBuilder.Api.Models
{
    public class Character
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public int Tier { get; set; } = 1;
        public int MainPointPool { get; set; }
        public int SpecialAttacksPointPool { get; set; }
        public int UtilityPointPool { get; set; }

        // Make navigation properties virtual for lazy loading
        [JsonIgnore]
        public virtual CombatAttributes? CombatAttributes { get; set; }
        [JsonIgnore]
        public virtual UtilityAttributes? UtilityAttributes { get; set; }
        [JsonIgnore]
        public virtual List<Expertise> Expertise { get; set; } = new();
        [JsonIgnore]
        public virtual List<SpecialAttack> SpecialAttacks { get; set; } = new();
        [JsonIgnore]
        public virtual List<UniquePower> UniquePowers { get; set; } = new();
    }
}
--------------------------------------------------

File: models\Entities\CharacterArchetypes.cs
Content:
using System.ComponentModel.DataAnnotations;

namespace VitalityBuilder.Api.Models;

public class CharacterArchetypes
{
    public int Id { get; set; }
    public MovementArchetype MovementArchetype { get; set; } = null!;
    public AttackTypeArchetype AttackTypeArchetype { get; set; } = null!;
    public EffectTypeArchetype EffectTypeArchetype { get; set; } = null!;
    public UniqueAbilityArchetype UniqueAbilityArchetype { get; set; } = null!;
    public SpecialAttackArchetype SpecialAttackArchetype { get; set; } = null!;
    public UtilityArchetype UtilityArchetype { get; set; } = null!;
    
    public int CharacterId { get; set; }
    public Character Character { get; set; } = null!;
}

public class MovementArchetype
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public MovementArchetypeType Type { get; set; }
    public Dictionary<int, int> SpeedBonusByTier { get; set; } = new();
    public bool IgnoresOpportunityAttacks { get; set; }
    public bool IgnoresDifficultTerrain { get; set; }
    public bool IsImmuneToProne { get; set; }
    public float MovementMultiplier { get; set; } = 1.0f;
    
    public int CharacterArchetypesId { get; set; }
    public CharacterArchetypes CharacterArchetypes { get; set; } = null!;
}

public enum MovementArchetypeType
{
    Swift,
    Skirmisher,
    ParkourRunner,
    Behemoth,
    Bulwark,
    Vanguard,
    Mole,
    Flight,
    Teleportation,
    Portal,
    Swinging,
    SuperJump
}

public class AttackTypeArchetype
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public AttackTypeArchetypeCategory Category { get; set; }
    public int AccuracyPenalty { get; set; }
    public int EffectPenalty { get; set; }
    public bool BypassesAccuracyChecks { get; set; }
    public bool HasFreeAOE { get; set; }
    
    public int CharacterArchetypesId { get; set; }
    public CharacterArchetypes CharacterArchetypes { get; set; } = null!;
}

public enum AttackTypeArchetypeCategory
{
    AOESpecialist,
    DirectSpecialist,
    SingleTarget
}

public class EffectTypeArchetype
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public EffectTypeCategory Category { get; set; }
    public bool HasAccessToAdvancedConditions { get; set; }
    public int DamagePenalty { get; set; }
    public int ConditionPenalty { get; set; }
    public bool RequiresHybridEffects { get; set; }
    
    public int CharacterArchetypesId { get; set; }
    public CharacterArchetypes CharacterArchetypes { get; set; } = null!;
}

public enum EffectTypeCategory
{
    DamageSpecialist,
    HybridSpecialist,
    CrowdControl
}

public class UniqueAbilityArchetype
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public UniqueAbilityCategory Category { get; set; }
    public int ExtraQuickActions { get; set; }
    public int ExtraPointPool { get; set; }
    public Dictionary<string, int> StatBonuses { get; set; } = new();
    
    public int CharacterArchetypesId { get; set; }
    public CharacterArchetypes CharacterArchetypes { get; set; } = null!;
}

public enum UniqueAbilityCategory
{
    VersatileMaster,
    Extraordinary,
    CutAbove
}

public class SpecialAttackArchetype
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public SpecialAttackCategory Category { get; set; }
    public int BasePoints { get; set; }
    public int MaxSpecialAttacks { get; set; }
    public float LimitPointMultiplier { get; set; }
    public bool CanTakeLimits { get; set; }
    public List<string> RequiredLimits { get; set; } = new();
    
    public int CharacterArchetypesId { get; set; }
    public CharacterArchetypes CharacterArchetypes { get; set; } = null!;
}

public enum SpecialAttackCategory
{
    Normal,
    Specialist,
    Paragon,
    OneTrick,
    Straightforward,
    SharedUses,
    DualNatured,
    Basic
}

public class UtilityArchetype
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public UtilityCategory Category { get; set; }
    public int BaseUtilityPool { get; set; }
    public bool CanPurchaseExpertise { get; set; }
    public float TierBonusMultiplier { get; set; }
    public List<string> Restrictions { get; set; } = new();
    
    public int CharacterArchetypesId { get; set; }
    public CharacterArchetypes CharacterArchetypes { get; set; } = null!;
}

public enum UtilityCategory
{
    Specialized,
    Practical,
    JackOfAllTrades
}
--------------------------------------------------

File: models\Entities\CombatAttributes.cs
Content:
namespace VitalityBuilder.Api.Models;

public class CombatAttributes
{
    public int Id { get; set; }
    public int Focus { get; set; }
    public int Power { get; set; }
    public int Mobility { get; set; }
    public int Endurance { get; set; }

    public int CharacterId { get; set; }
    public Character Character { get; set; } = null!;
}
--------------------------------------------------

File: models\Entities\Expertise.cs
Content:
namespace VitalityBuilder.Api.Models;

public class Expertise
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Category { get; set; } = string.Empty;
    public int Cost { get; set; }
    public string Description { get; set; } = string.Empty;

    public int CharacterId { get; set; }
    public Character Character { get; set; } = null!;
}
--------------------------------------------------

File: models\Entities\SpecialAttack.cs
Content:
namespace VitalityBuilder.Api.Models;

public class SpecialAttack
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string AttackType { get; set; } = string.Empty;
    public string EffectType { get; set; } = string.Empty;
    public List<string> Limits { get; set; } = new();
    public List<string> Upgrades { get; set; } = new();

    public int CharacterId { get; set; }
    public Character Character { get; set; } = null!;
}
--------------------------------------------------

File: models\Entities\UniquePower.cs
Content:
namespace VitalityBuilder.Api.Models;

public class UniquePower
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Category { get; set; } = string.Empty;
    public int Cost { get; set; }
    public string Description { get; set; } = string.Empty;

    public int CharacterId { get; set; }
    public Character Character { get; set; } = null!;
}
--------------------------------------------------

File: models\Entities\UtilityAttributes.cs
Content:
namespace VitalityBuilder.Api.Models;
public class UtilityAttributes
{
    public int Id { get; set; }
    public int Awareness { get; set; }
    public int Communication { get; set; }
    public int Intelligence { get; set; }

    public int CharacterId { get; set; }
    public Character Character { get; set; } = null!;
}
--------------------------------------------------
